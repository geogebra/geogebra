//in -- uniform
uniform mat4    modelview ;  // Incomming data used by the vertex shader (uniform and attributes)
uniform mat4    projection;  
//uniform mat3	normalMatrix; // no need since light position is model view system based
uniform vec3	lightPosition;
uniform vec4	eyePosition;
uniform vec2	ambiantDiffuse;
uniform int		enableLight;
uniform int		culling;
uniform vec4	color;
uniform vec3	normal;
uniform vec4	center;

uniform int labelRendering;
uniform vec3 labelOrigin;

//in -- attributes
attribute vec3  attribute_Position;  
attribute vec3  attribute_Normal;  
attribute vec4  attribute_Color;  
attribute vec2	attribute_Texture;   


//out
varying vec4    varying_Color;  
varying vec2	coordTexture;
varying vec3    realWorldCoords;

void main(void)
{
   
  
  // position
  vec3 position;
  if (center.w > 0.0){ // use center
  	position = vec3(center) + center.w * attribute_Position;
  }else{
  	position = attribute_Position;
  }
  gl_Position = projection * modelview * vec4(position, 1.0); 
  
  if (labelRendering == 1){ // use special origin for labels
      realWorldCoords = labelOrigin;
  }else{
	  realWorldCoords = position;
  }
  
  
  // color
  vec4 c;
  if (color[0] < 0.0){ // then use per-vertex-color
  	c = attribute_Color;
  }else{ // use per-object-color
  	c = color;
  }
  
  // light
  if (enableLight == 1){// color with light
	  vec3 n;
	  if (normal.x > 1.5){ // then use per-vertex normal
	  	n = attribute_Normal;
	  }else{
	  	n = normal;
	  }
	  
	  float factor = dot(n, lightPosition);
	  
	  if (culling == 1){ // front-face culling
	  	factor = -factor;
	  }
	  
	  if (factor < 0.0){ 
	  	factor = 0.0;
	  }
	  
	  float ambiant = ambiantDiffuse[0];
	  float diffuse = ambiantDiffuse[1];
	  
	  /*
	  // specular
	  
	  // makes natural specular
	  vec3 viewDirection;
	  if (eyePosition[3] < 0.5){ // parallel projection
	  	viewDirection = vec3(eyePosition);
	  }else{ // perspective projection
	  	viewDirection = position - vec3(eyePosition);
	  }
	  vec3 lightReflect = normalize(reflect(lightPosition, n));
	  float specular = dot(lightReflect, viewDirection);
	  
	  
	  // makes specular has if eye was lighting
	  //float specular = - dot(n, viewDirection);
	  //if (culling == 1){ // front-face culling
	  //	specular = -specular;
	  //}
	  
	  
	  // specular as diffuse
	  //float specular = factor;
	  
	  if (specular > 0.0){
	  	specular = pow(specular, 32.0);
	  }else{
	  	specular = 0.0;
	  } 
	  
	  // specular light from eye
	  //varying_Color.rgb = (ambiant + diffuse * factor) * c.rgb + 0.5 * specular * vec3(1.0, 1.0, 1.0);
	  //specular natural way
	  varying_Color.rgb = (ambiant + diffuse * factor) * c.rgb + 0.8 * specular * vec3(1.0, 1.0, 1.0);
	  
	  */
	  
	  
	  
	  // no specular
	  varying_Color.rgb = (ambiant + diffuse * factor) * c.rgb;
	  varying_Color.a = c.a;
	  
  }else{ //no light
	  varying_Color = c;
  }

  
      
  // texture
  coordTexture = attribute_Texture;
  
}