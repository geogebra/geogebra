/* 
GeoGebra - Dynamic Mathematics for Everyone
Copyright Markus Hohenwarter, http://www.geogebra.org

This file is part of GeoGebra.

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by 
the Free Software Foundation; either version 2 of the License, or 
(at your option) any later version.
*/

/*
 * Parser.jj
 * javacc definition file to generate Parser.java
 * <BR> <BR>
 * This class provides a static function to  
 * parse a String and return an appropriate ValidExpression.
 * Direct subclasses of ValidExpression are: 
 * Command, Equation (in x, y), Parametric, Vector (for cartesian and polar points),
 * ExpressionNode (for number or vector arithmetic expressions)
 *
 * <BR><BR>
 * Some examples of possible recognized input:<BR>
 * Point   <CODE> P = (3,4) </CODE><BR>
 * Point   <CODE> P = (7; 20?) </CODE><BR>
 * Line    <CODE> g: X = (3,4) + t (7,2) </CODE><BR>
 * Line    <CODE> g: y = 3x - 9 </CODE><BR>
 * Line    <CODE> h: 5x + 7y = -2 </CODE><BR>
 * Circle  <CODE> k: (x-5)^2 + (y-2)^2 = 25 </CODE><BR>
 * Circle  <CODE> k: (x-5)? + (y-2)? = 25 </CODE><BR>
 * Conic   <CODE> c: 5x^2 - 7y^2 + 6xy - 3x + 2y = 7 </CODE>
 * Command <CODE> P = Intersect[ g, h ] </CODE>
 * Number  <CODE> r = 25 </CODE>
 * <BR><BR>
 * All arithmetic expressions (operators: +, -, *, /, ^) are 
 * valid as long as they obey the following rules:
 * Variables are x or y. Divisors and Exponents must be constant
 * numbers. The "*" operator may be omitted.
 *
 * @author Markus Hohenwarter
 * @version 10.4.2004
 */   

PARSER_BEGIN(Parser)
package org.geogebra.common.kernel.parser;

import org.geogebra.common.kernel.Construction;
import org.geogebra.common.kernel.arithmetic.*;
import org.geogebra.common.kernel.arithmetic3D.MyVec3DNode;
import org.geogebra.common.kernel.geos.GeoCasCell;
import org.geogebra.common.kernel.geos.GeoElement;
import org.geogebra.common.kernel.geos.GeoElementSpreadsheet;
import org.geogebra.common.kernel.geos.GeoNumeric;
import org.geogebra.common.kernel.parser.ParserInterface;
import org.geogebra.common.kernel.StringTemplate;
import org.geogebra.common.main.MyError;
import org.geogebra.common.main.Localization;
import org.geogebra.common.main.BracketsError;
import org.geogebra.common.util.StringUtil;
import org.geogebra.common.util.Unicode;
import org.geogebra.common.kernel.Kernel;
import org.geogebra.common.kernel.parser.cashandlers.CommandDispatcherGiac;
import org.geogebra.common.main.App;
import org.geogebra.common.plugin.Operation;

import java.util.ArrayList;
import java.util.Vector;

@SuppressWarnings("javadoc")
public class Parser implements ParserInterface{

    private Kernel kernel;
    private App app;
    private Localization loc;
    private boolean GeoGebraCASParsing = false;
    private boolean ExternalCASParsing = false;
  private boolean GiacParsing = false;
  private boolean enableVectors = true;
  private FunctionParser functionParser;
  private ArrayList<ExpressionNode > undecided = new ArrayList<ExpressionNode >();
    
    public Parser(Kernel kernel) {
       this ( new java.io.StringReader("") ); // dummy stream for parser initing
         this.kernel = kernel;
         functionParser = new FunctionParser(kernel);
         app = kernel.getApplication();
         loc = app.getLocalization();
    }

    public Kernel getKernel() 
    {
      return kernel;
    }
    
    // reset for new parsing
    public void myReInit(String parseString) throws ParseException {
        if(!kernel.getConstruction().isFileLoading() && StringUtil.checkBracketsBackward(StringUtil.ignoreIndices(parseString))>=0){
          throw new BracketsError(loc,parseString);
        }
      ReInit(new java.io.StringReader(StringUtil.fixVerticalBars(parseString)));      
      GeoGebraCASParsing = false;
      ExternalCASParsing = false;
      GiacParsing = false;
      enableVectors = kernel.getAlgebraProcessor().enableVectors();
      undecided.clear();
    }

    /**
     * Parses a String and returns a ValidExpression Object     
     */
    public ValidExpression parseGeoGebraExpression(String parseString) throws ParseException {           
        myReInit( parseString.charAt(0)=='=' ? parseString.substring(1):parseString );                         
        ValidExpression ret = buildValidExpression();
        processUndecided();
        return ret;     
    }
    
     /**
     * Parses a String and returns a ValidExpression Object     
     */
    public ValidExpression parseGeoGebraCAS(String parseString, GeoCasCell cell) throws ParseException {           
        myReInit( parseString );
        // parse x^2 + y^2 as an expression and don't throw Incomplete Equation error
        GeoGebraCASParsing = true;                        
        ValidExpression ret = buildCASExpression(cell);
        return ret;     
    }
    
    /**
     * Parses a Giac String and returns a ValidExpression Object     
     */
    public ValidExpression parseGiac(String parseString) throws ParseException {           
        myReInit( parseString ); 
        ExternalCASParsing = true;
        GiacParsing = true;                     
        return buildGiacExpression();     
    }
    
    /**
     * Parses a String and returns a Function Object     
     */
    public Function parseFunction(String parseString) 
    throws ParseException {    
        myReInit( parseString );                           
        Function ret = function();
        processUndecided();
        return ret;           
    }

    /**
     * Parses a String and returns a Function Object     
     */
    public FunctionNVar parseFunctionNVar(String parseString) 
    throws ParseException {    
        myReInit( parseString );                           
        FunctionNVar ret = functionNVar();
        processUndecided();
        return ret;           
    }
    
    /**
     * Parses a String and returns an ExpressionNode Object     
     */
    public ExpressionNode parseCmdExpression(String parseString) 
    throws ParseException {    
        myReInit(parseString );                           
        ExpressionNode ret = expressionOrEquation().wrap();
        processUndecided();
        return ret;           
    }
    
    /**
     * Parses a String and returns an ExpressionNode Object     
     */
    public ExpressionNode parseExpression(String parseString) 
    throws ParseException {    
        myReInit( parseString);                           
        ExpressionNode ret = expressionNoFreeVars();
        processUndecided();
        return ret;   
    }
    
    /**
     * Parses a String if it is a label
     */
    public String parseLabel(String parseString) 
    throws ParseException {    
        myReInit(parseString );                           
        return label().image;      
    }
    private ExpressionNode makePower(ExpressionValue v,ExpressionValue e){
      if(v.isExpressionNode() && ((ExpressionNode)v).getOperation()
        ==Operation.MULTIPLY_OR_FUNCTION && !((ExpressionNode)v).hasBrackets()){
        return new ExpressionNode(kernel,((ExpressionNode)v).getLeft(),Operation.MULTIPLY,
          new ExpressionNode(kernel,((ExpressionNode)v).getRight(),Operation.POWER,e));
      }
      return new ExpressionNode(kernel,v,Operation.POWER,e);
  }

  private void processUndecided(){
    for(ExpressionNode en: undecided)
      en.setOperation(Operation.MULTIPLY);
    undecided.clear();    
   }

   private ExpressionValue ifVectorsEnabled(ExpressionValue def){     return enableVectors ? def : new MyDouble(kernel,Double.NaN); }

   
}
PARSER_END(Parser)



SKIP : {
    " " 
  | "\r"
  | "\t"
  | "\n"
}

//TOKEN : {
//    < EOL: ";" >
//}

/* OPERATORS */
TOKEN :  {   
    < ASSIGNMENT: ( ":=" | "\u2254" ) >
  | < DELAYED_ASSIGNMENT: ( "::=") >
  | < VERTICAL_BAR: "|" >
  | < NOT: ("\u00ac") > 
  | < OR:    ("||" | "\u2228" ) >
  | < AND:    ("&&" | "\u2227" ) >
  | < IMPLICATION:    ("->" | "\u2192") >
  | < SEQUENCE_OPERATOR:    ("\u2026") >
  | < EQUAL_BOOLEAN: ("==" | "\u225f" ) >
  | < NOT_EQUAL: ("!=" | "\u2260" | "<>" ) >
  | < IS_ELEMENT_OF: "\u2208" >
  | < IS_SUBSET_OF: "\u2286" >
  | < IS_SUBSET_OF_STRICT: "\u2282" >
  | < SET_DIFFERENCE: "\\" >
  | < LESS:    "<" >
  | < GREATER:  ">" >
  | < LESS_EQUAL: ("<=" | "\u2264") >
  | < GREATER_EQUAL: (">=" | "\u2265") >
 // | < INEQUALITY: ( < LESS > | < LESS_EQUAL > | < GREATER_EQUAL > | < GREATER > ) >
  | < PARALLEL: "\u2225" >
  | < PERPENDICULAR: "\u22a5" >
  | < EQUAL:    ("=" | "%=") > // %= for Giac
  | < PLUS:     "+" >
  | < MINUS:    ("-"  | "\u2013" | "\u2212") >
  | < SUPERSCRIPT_MINUS: "\u207b" >
  | < POWER:    ("^" | "**" | "\u02C6") >  
    // dot operators for multiplication sign
  | < MULTIPLY: ("*" | "\u22c5" | "\u2219") >
  | < VECTORPRODUCT: "\u2297" >
  | < DIVIDE:   ("/" | "\u00f7") >
  | < FACTORIAL: "!" >  
  | < UNDEFINED: ( "?" | "\ufffd" | "Undefined" | "NaN" ) >
//  | < POWER0:   "\u2070" >
//  | < POWER1:   "\u00b9" >
//  | < SQUARED:  "\u00b2" >
//  | < CUBED:    "\u00b3" >
//  | < POWER4:   "\u2074" >
//  | < POWER5:   "\u2075" >
//  | < POWER6:   "\u2076" >
//  | < POWER7:   "\u2077" >
//  | < POWER8:   "\u2078" >
//  | < POWER9:   "\u2079" >
  | < POWERN: (<SUPERSCRIPT_MINUS>)? ( <INDEXDIGIT> )+ >
  | < #INDEXDIGIT:                                     // unicode digits
       [ "\u2070","\u2074"-"\u2079","\u00b9","\u00b2","\u00b3"] >
  | < PI:       ( "pi" | "Pi" | "\u03c0" ) >
  | < EULER_GAMMA:       ( "euler_gamma" | "\u212F_\u03B3" ) > // Eulerï¿½Mascheroni constant
  | < E:        ("\u212f") > // Euler constant
  | < IMAGINARY: ("\u03af") > // imaginary constant
  // 02da is "Ring Above", Alt-k in iPad
  // 00ba is Masculine ordinal indicator Alt-zero on OSX
  | < DEGREE:   ( "\u00b0" | "\u02da" | "\u00ba" | "deg") >
  | < GRADIAN:   ( "\u1D4D") > // superscript g
  | < INFINITY: ("\u221e" | "Infinity" | "inf" | "infinity") >
  | < RAD:      "rad" >
  | < DERIVATIVE: "'" >
  | < TRUE:     ( "true" | "True" ) >
  | < FALSE:    ( "false" | "False" ) >
  | < DECIMAL_POINT:    ( "." | "\u066b" ) > // Arabic decimal point
  | < COMMA:    ( "," | "\u060c" ) > // Arabic comma
}

TOKEN : {      
      < VARX: "x" >
  |    < VARY: "y" >
  |    < VARZ: "z" >
  //|     < PARAMETRICVAR: (("\u0058") /*| ( ("(") (< VARX >) (< COMMA >) (< VARY >) (")"))*/) > // X 
  |     < FLOAT:  (<INTEGER> | <DECIMAL_POINT>)+ > //deliberately trap eg 1.2.3.4 , 1..2 here, error then thrown in MyDouble.parseDouble()
  |     < EFLOAT: <FLOAT> ("E") (<PLUS> | <MINUS>)? <INTEGER> >
  |     < INTEGER: ( <DIGIT> )+ >
  |     < #DIGIT:                                     // unicode digits
         [
          "\u0030"-"\u0039", // Roman
          "\u0660"-"\u0669", // Arabic-Indic
          "\u06f0"-"\u06f9", // Extended Arabic-Indic
          "\u0966"-"\u096f", // Devanagari (Hindi)
          "\u09e6"-"\u09ef", // Bengali
          "\u0a66"-"\u0a6f", // Gurmukhi (Punjabi)
          "\u0ae6"-"\u0aef", // Gujurati
          "\u0b66"-"\u0b6f", // Oryia
          "\u0be6"-"\u0bef", // Tamil
          "\u0c66"-"\u0c6f", // Telugu
          "\u0ce6"-"\u0cef", // Kannada
          "\u0d66"-"\u0d6f", // Malayalam
          "\u0e50"-"\u0e59", // Thai
          "\u0ed0"-"\u0ed9", // Lao
          "\u1040"-"\u1049", // Myanmar (Burmese)
          "\u0f20"-"\u0f29", // Tibetan
          "\u1b50"-"\u1b59", // Balinese
          "\u1bb0"-"\u1bb9", // Sudanese
          "\u1c40"-"\u1c49", // Lepcha
          "\u1c50"-"\u1c59", // Ol Chiki
          "\u17e0"-"\u17e9", // Khmer
          "\u1810"-"\u1819", // Mongolian
          "\ua8d0"-"\ua8d9"  // Saurashtra
         ]       
    > 
}   

TOKEN : { 
   // labels for cells in the spreadsheet
   <SPREADSHEET_LABEL: ("$")?(["A"-"Z"]|["a"-"z"])+("$")?(["0"-"9"])+ > // e.g. B12
 | 
   // standard case: labels for GeoElements and command names
   < LABEL:  
    <LETTER> ( <LETTER> | <DIGIT> | "'" )* (<INDEX>)? (<LETTER> | <DIGIT> | "'" )*>
 // |  < #INDEX:  "_" (  <CHAR>  | ("{" (<CHAR>)+ "}") )  >  
 |  < #INDEX:  "_" (  <CHAR>  | ("{" (~["}"])+ "}" ) )  >  
 | < #LETTER:  // unicode letters
       [
        "$", // for absolute references in the spreadsheet
        "\u0041"-"\u005a",      //upper case (A-Z)
        "\u0061"-"\u007a",      //lower case (a-z)
        "\u00b7",         // middle dot (for Catalan)
        "\u00c0"-"\u00d6",      //accentuated letters
        "\u00d8"-"\u00f6",    //accentuated letters
        "\u00f8"-"\u01bf",    //accentuated letters
        "\u01c4"-"\u02a8",    //accentuated letters
        "\u0391"-"\u03f3",     // Greek 
         "\u0401"-"\u0481",    // Cyrillic
        "\u0490"-"\u04f9",    // Cyrillic
        "\u0531"-"\u1ffc",       // a lot of signs (Arabic, accentuated, ...)
        "\u3041"-"\u3357",      // Asian letters   
        "\u4e00"-"\ud7a3",    // Asian letters
        "\uf71d"-"\ufa2d",    // Asian letters
        "\ufb13"-"\ufdfb",    // Armenian, Hebrew, Arabic
        "\ufe80"-"\ufefc",    // Arabic
        "\uff66"-"\uff9d",    // Katakana
        "\uffa1"-"\uffdc"    // Hangul
       ] >
       
}



// labels for function names
TOKEN: {
    < X_FUNC:  ("x" | "xcoord")  ("("|"[")>
|  < Y_FUNC:  ("y" | "ycoord")   ("("|"[")> 
|  < Z_FUNC:  ("z" | "zcoord")   ("("|"[")>
|  < RANDOM_FUNC:  "random()"  >
|   < POLAR_SEPARATOR: ( "\u2221" | ";" ) > // separator used by Giac instead of ;
|    < SQRT_SHORT: "\u221a" > 
|   < FUNCTION_LABEL: (<SPREADSHEET_LABEL> | <LABEL> ) ("("|"[") >
|   < FUNCTION_POWER_LABEL: (<SPREADSHEET_LABEL> | <LABEL> ) (< POWERN > )("("|"[") >
}

 TOKEN : {
 < TEXT: "\""  (<CHAR>)* "\"" > |
 < #CHAR: ["\u0000"-"\u0021", "\u0023"-"\uffff"]  >    
}
                         
     

/**
 * for GeoGebra input field
 * validexpression =    
 *                  labellist() = command() |           // e.g. {A,B} = Intersect[c, g]
 *                      <LABEL> : parametric() |        // e.g. X = (3,2) + t (2,1)              
 *                      <LABEL> = expressionn()      // arithmetic expression of floats, vectors and vars
 *                      <LABEL> : equation()        // equation in x an y
             <LABEL>(x) = function()   // function in x, e.g. f(x) = 3x^3 - sqrt(x)
 */
ValidExpression buildValidExpression() : 
{
    ValidExpression ve = null;
    ExpressionNode conditions = null;
    Token l = new Token();
} 
{         
     (       
        // f(x) =  x^2 + 3  
        LOOKAHEAD(2147483647)
        ve = functionExpressionnode()          
     |             
       // spreadsheet range like A1:B2
    LOOKAHEAD (3)
    ve = spreadsheetRange()     
     |       
        // special case "A: (3,2)" should become a point  
        // CAS assignment "a := 5" should be supported too
        // inequalities "a: 3x + 4y < 7" and intervalls "b: 3 < x < 7" can be named too                                  
      LOOKAHEAD(2147483647)  
      l = label() (":" | <ASSIGNMENT> )  ve = expressionOrEquation()
   |
        LOOKAHEAD(2147483647)
        (          (ve = expressionOrEquation())        {
          if(ve instanceof Equation)          {			ve = ((Equation)ve).equationOrAssignment();
          }        })
        (conditions = conditions()
        {
			ve = new ExpressionNode(kernel, conditions, Operation.IF, ve);
        })?
                       
     |       
        LOOKAHEAD(2147483647)                               
      ve = cartesianvector_special()
  |
  LOOKAHEAD(2147483647)
  ve = cartesianvector3D_special()
  |
      LOOKAHEAD(2147483647)    
        ve = polarvector_special()  
    )                     
    ( <POLAR_SEPARATOR> | <EOF> )     
    {                      
        if (ve.labelCount() == 0)
        {
          ve.addLabel(l.image);  // standard case
        }                         
        return ve;
    }    
}

/**
 *  parse GeoGebra CAS input
 */
ValidExpression buildCASExpression(GeoCasCell cell) : 
{
    ValidExpression ve;
    Token l = new Token();
    Token assign = null;
} 
{         
        // CAS function
       // f(a) := a^2 + 3a
     (
        LOOKAHEAD(2147483647)   
        ve = casFunction(cell)
    |     
         // labeled equation, e.g. g: 3x + y = 7
         // assignment         
        // b := 27 + c, also allow x := 5, see http://www.geogebra.org/trac/ticket/946
        LOOKAHEAD(2147483647)    
    l = casVar() (assign= ":" |assign = <ASSIGNMENT> | assign = <DELAYED_ASSIGNMENT > ) ve = expressionOrEquation()
   |      
         // equation, e.g. 3x + y = 7
         LOOKAHEAD(2147483647)   
         ve = expressionOrEquation()         
  )                     
    ( <POLAR_SEPARATOR> | <EOF> )     
    {   
      // remember label      
      if (l.image != null)
      {
          if(":".equals(assign.image) &&
          GeoElementSpreadsheet.isSpreadsheetLabel(ve.toString(StringTemplate.defaultTemplate)))
          {
            ExpressionNode startCell = new ExpressionNode(kernel, new Variable(kernel, l.image));
    ExpressionNode endCell = new ExpressionNode(kernel, new Variable(kernel, ve.toString(StringTemplate.defaultTemplate)));
    Command cmd = new Command(kernel, "CellRange", false, !ExternalCASParsing ); // don't translate name
    cmd.addArgument(startCell);
    cmd.addArgument(endCell);
    return cmd;
          }           
          ve.addLabel(l.image);
          if(cell != null){
          	cell.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
          }
       }                          
        return ve;
    }    
}


/**
 * convert Giac String to GeoGebra string
 */
private ValidExpression buildGiacExpression() : 
{
    ValidExpression ve;
} 
{         
    (     
    // try to parse Giac string as standard GeoGebra expression 
      ve = buildCASExpression(null)                 
  )                     
    ( <POLAR_SEPARATOR> | <EOF> )     
    {                                  
        return ve;
    }    
}

/**
 * (<VARZ> | <LABEL> | <SPREADSHEET_LABEL>) 
 */
Token label():
{     
    Token t;
}
{             
       ( t = <VARZ> | t = <SPREADSHEET_LABEL> |  t = <LABEL> )
        {  return t;   }
}

/**
 * (<VARX> | <VARY> | <VARZ> | <LABEL> | <SPREADSHEET_LABEL>) 
 */
Token casVar():
{
  Token t;
}
{
  (t = <VARX> | t = <VARY> | t = <VARZ> | t = <LABEL> | t = <SPREADSHEET_LABEL>)
  {
    return t;
  }
}


/**
 * command =     <LABEL> [ argument (, argument)* ]  
 */
ValidExpression command():
{     
    Command c;
    Token t;
    String cmdName;
    ValidExpression en;
}
{   
  (
       (t = <FUNCTION_LABEL>) // includes (
      { cmdName = t.image.substring(0,t.image.length()-1);
        c = new Command(kernel, cmdName, true, !ExternalCASParsing );    } 
      (   ( en = expressionOrEquation()  { c.addArgument( en.wrap() ); } )?
          ( <COMMA> en = expressionOrEquation() { c.addArgument( en.wrap() ); } )*
      (")"|"]") )
      { if (GiacParsing)
      {
        ExpressionNode res = CommandDispatcherGiac.processCommand(cmdName,c,kernel);
        if (res != null)
          return res;
      }
      return c; }
  )
}


/******************************************************************
 * ARTIHMETIC FOR NUMBERS AND 2D VECTORS WITH VARIABLES
 * plus
 * ARTIHMETIC FOR POLYNOMIALS WITH VARIABLES "x" AND "y"
 * exponents must be integers >= 0
 * divisors must be simplifyable to numbers
 ******************************************************************/

/**
 * expression = expressionnode
 */
ExpressionNode expressionNoFreeVars():
{
    ExpressionNode rhs;
}
{    
    rhs = expressionnode()              
    {
      // Giac uses x,y not ggbtmpvarx/y
        if (!GeoGebraCASParsing && !GiacParsing && rhs.containsFreeFunctionVariable(null)) {
          throw new MyError(loc, "IncompleteEquation");
        }
        
        // since v3.0: commands have to take care of resolving the variables of 
        // their arguments on their own, e.g. Sequence[ (i, i^2), i , 1, 10 ]       
    //rhs.resolveVariables();
        return rhs;
    }
}

/**
 * function = functionExpressionnode 
 */
Function  function():
{
    ExpressionNode rhs;
    Function f;
}
{          
(
     // f(x) =  x^2 + 3  
      rhs = functionExpressionnode()
      {
        if (rhs.getLeft() instanceof Function) {
          f = (Function) rhs.getLeft();
        }
        else {
            f = new Function(rhs);            
        }
        f.setLabel(rhs.getLabel());         
        return f;
      }   
)     
}

/**
 * functionNVar = functionExpressionnode 
 */
FunctionNVar  functionNVar():
{
    ExpressionNode rhs;
    FunctionNVar f;
}
{          
(
     // f(x) =  x^2 + 3  
      rhs = functionExpressionnode()
      {
        if (rhs.getLeft() instanceof FunctionNVar) {
          f = (FunctionNVar) rhs.getLeft();
        }
        else {
            f = new FunctionNVar(rhs);            
        }
        f.setLabel(rhs.getLabel());         
        return f;
      }   
)     
}

ExpressionNode conditions():
{
    
    ExpressionNode condition = null;
    ExpressionNode conditions = null;    
}
{  
(  <COMMA> (condition = expressionnode())
          {
            conditions = conditions == null ? condition : new ExpressionNode(kernel, conditions, Operation.AND, condition);
          })+
          {			return conditions;
          }
}        
/**
 * function =   f(var1, var2) = expressionnode 
 *        f(var) := expressionnode 
 *        f(var) = command
 */
ExpressionNode functionExpressionnode():
{
    ExpressionNode rhs;
    ExpressionNode cond = null;
    Token funName = null;
    Token varName = null;
    ArrayList<String> localVars;
}
{          
(
      // single or multi-variable function definition
     // f(a) =  a^2 + 3
     // g(x,y) := x * y
     (
       funName = <FUNCTION_LABEL> |  // includes "(" at end
       funName = <Z_FUNC> // includes "(" at end
     ) 
         // local variables, allow function of y and deal with it in GeoFunction constructor
         (( varName =  <VARX> | varName =  <VARY> | varName = label() )
           { localVars = new ArrayList<String>(); localVars.add(varName.image);
           kernel.getConstruction().registerFunctionVariable(varName.image);} )
      // optional second variable      
       (<COMMA> ( varName = casVar() )
       { localVars.add(varName.image);
       kernel.getConstruction().registerFunctionVariable(varName.image);} )* 
      // closing ) and assignment with expressionnode
          ")" ( <EQUAL > | <ASSIGNMENT> ) rhs = expressionnode() (cond = conditions())?
      {
          // allow f(y) in CAS but not in GeoGebra
    //  if (!ExternalCASParsing && !GeoGebraCASParsing && "y".equals(varName.image)) 
      //      throw new MyError(app, "InvalidInput");
      	if(cond != null)
      	{
			rhs = new ExpressionNode(kernel, cond, Operation.IF, rhs);
      	}
        String funLabel = funName.image.substring(0,funName.image.length()-1);   

      // command without variables: return expressionnode
      // only check for function variables outside of command, eg Derivative[f(x)]+x #4533
        if (rhs.getLeft() instanceof Command && !rhs.containsFreeFunctionVariable(null)) {
        rhs.setLabel(funLabel);
        return rhs;
      }
      

        // function: wrap function in ExpressionNode
      // number of vars
      int n = localVars.size();
      Operation op = app.getParserFunctions().get(funLabel,n);
      if(op!=null)
      {
        if(n==1)
        {
          return new Equation(kernel,new FunctionVariable(kernel,localVars.get(0)).wrap().apply(op),rhs).wrap();
        }
        MyList vars = new MyList(kernel, n);
        for (int i=0;i<n; i++){
          FunctionVariable funVar = new FunctionVariable(kernel,localVars.get(i));
          vars.addListElement(funVar);
        }
        return new Equation(kernel, functionParser.buildOpNode(op, vars), rhs).wrap();
      }
      
      FunctionVariable[] funVar = new FunctionVariable[n];
        for (int i=0;i<n; i++){
          funVar[i] = new FunctionVariable(kernel);
          funVar[i].setVarString(localVars.get(i));
        }

          switch (n) {
            case 1: // single variable function          
        Function fun = new Function(rhs, funVar[0]);
        fun.setLabel(funLabel);
        rhs = new ExpressionNode(kernel, fun);
        break;

             default: // multi variable function
             FunctionNVar funn = new FunctionNVar(rhs, funVar);
        funn.setLabel(funLabel);
        rhs = new ExpressionNode(kernel, funn);
             break;
          }             
           
           rhs.setLabel(funLabel);
           return rhs;
      }   
)
}

/**
 * CAS function =   label(var) := expressionnode 
 */
FunctionNVar casFunction(GeoCasCell cell):          
{
    ExpressionNode rhs,cond = null;
    Token funName = null;
    Token varName = null;
    Token assign = null;
    ArrayList<String> localVars;
}
{          
(
      // single or multi-variable function definition
     // f(a) =  a^2 + 3
     // g(x,y) := x * y
     (
       funName = <FUNCTION_LABEL> |  // includes "(" at end
       funName = <Z_FUNC> // includes "(" at end
     )    
         // local variables
         (( varName =  casVar() )
           { localVars = new ArrayList<String>(); localVars.add(varName.image); } )
      // optional second variable      
       (<COMMA> ( varName =  casVar() )
       { localVars.add(varName.image); } )* 
      // closing ) and assignment with expressionnode
          ")" (assign = <ASSIGNMENT> | assign = < DELAYED_ASSIGNMENT >) rhs = expressionnode() (cond = conditions())?
      {
        if(cond != null)
      	{
			rhs = new ExpressionNode(kernel, cond, Operation.IF, rhs);
      	}
        String funLabel = funName.image.substring(0,funName.image.length()-1);   

      // number of vars
      int n = localVars.size();
      
      FunctionVariable[] funVar = new FunctionVariable[n];
        for (int i=0;i<n; i++){
          funVar[i] = new FunctionVariable(kernel);
          funVar[i].setVarString(localVars.get(i));
        }

          switch (n) {
            case 1: // single variable function          
        Function fun = new Function(rhs, funVar[0]);
        fun.setLabel(funLabel);
        if(cell != null){
          	cell.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
        }
        return fun;

             default: // multi variable function
             FunctionNVar funn = new FunctionNVar(rhs, funVar);
        funn.setLabel(funLabel);
        if(cell != null){
          	cell.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
        }
        return funn;
          }
      }   
)   
}     


/**
 *  expression =  term <OR> term
 */
ExpressionNode expressionnode():
{
    ExpressionValue ret, f;
}
{
    ret = ORterm()                 
    ( <IMPLICATION>  f = ORterm()
        {                
           ret = new ExpressionNode(kernel, ret, Operation.IMPLICATION, f);                   
        }
    )*
    { 
      ExpressionNode en;
      if (ret.isExpressionNode())
        en = (ExpressionNode) ret;
      else
        en = new ExpressionNode(kernel, ret);
      
      //en.expandEquationExpressions();
      if (ExternalCASParsing)
        en.simplifyLeafs();
      return en; 
    }
}

/**
 *  expressionOrEquation =  equation | expressionnode 
 */
ValidExpression expressionOrEquation():
{
  	ExpressionNode en;
    ExpressionNode rhs = null;
}
{ 
     en = expressionnode()
      (  <EQUAL> rhs = expressionnode()
            
      )?
  {                
    return  rhs == null ? en : new Equation(kernel, en, rhs);           
  }
}

/**
 * ANDterm =   COMPAREterm <AND> COMPAREterm 
 */
ExpressionValue ANDterm():
{
    ExpressionValue ret, f;
}
{
    ret = COMPAREterm()           
    ( <AND>  f = COMPAREterm() 
        {
          ret = new ExpressionNode(kernel, ret, Operation.AND, f);             
        }     
    )*
    { return ret; }  
}

/**
 * ORterm =   ANDterm <OR> ANDterm 
 */
ExpressionValue ORterm():
{
    ExpressionValue ret, f;
}
{
    ret = ANDterm()           
    ( <OR>  f = ANDterm() 
        {
          ret = new ExpressionNode(kernel, ret, Operation.OR, f);             
        }     
    )*
    { return ret; }  
}

/**
 * COMPAREterm =   listopnode ("==" | "<" | "<=" | ">" | ">=") listopnode 
 */
ExpressionValue COMPAREterm():
{
    ExpressionValue left, right;
    ExpressionNode result;   
    Vector<ExpressionNode> andList = null; // support multiple comparisons like 3 < x < 7
}
{
    left = listopnode()  
    (         
       (
         (<EQUAL_BOOLEAN>  right = listopnode()
       {            
         if (ExternalCASParsing)
             result = new ExpressionNode(kernel, new Equation(kernel, left, right));
         else
                result = new ExpressionNode(kernel, left, Operation.EQUAL_BOOLEAN, right);  
         }
       )   
     |   
       (<NOT_EQUAL>  right = listopnode()
       {            
           result = new ExpressionNode(kernel, left, Operation.NOT_EQUAL, right);  
         }
       )   
     |  
       (<IS_SUBSET_OF>  right = listopnode()
       {            
           result = new ExpressionNode(kernel, left, Operation.IS_SUBSET_OF, right);  
         }
       )   
     |   
       (<IS_SUBSET_OF_STRICT>  right = listopnode()
       {            
           result = new ExpressionNode(kernel, left, Operation.IS_SUBSET_OF_STRICT, right);  
         }
       )   
     |   
       (<LESS>  right = listopnode()
       {            
           result = new ExpressionNode(kernel, left, Operation.LESS, right);  
         }
       ) 
     |
       (<GREATER>  right = listopnode()
       {            
           result = new ExpressionNode(kernel, left, Operation.GREATER, right);  
         }
       ) 
     |
       (<LESS_EQUAL>  right = listopnode()
       {            
           result = new ExpressionNode(kernel, left, Operation.LESS_EQUAL, right);  
         }
       ) 
     |
       (<GREATER_EQUAL>  right = listopnode()
       {            
           result = new ExpressionNode(kernel, left, Operation.GREATER_EQUAL, right);  
         }
       ) 
      |
         (<PARALLEL>  right = listopnode()
       {            
           result = new ExpressionNode(kernel, left, Operation.PARALLEL, right);  
         }
         ) 
      |
         (<PERPENDICULAR>  right = listopnode()
       {            
           result = new ExpressionNode(kernel, left, Operation.PERPENDICULAR, right);  
         }
        )
     )                    
     {
        // store all AND parts
        // e.g. 3 < x < 7 should get stored as 3 < x && x < 7
        if (andList == null)
      andList = new Vector<ExpressionNode>();
    andList.add(result);
    left = right;
     }
    )* 
    {
      if (andList != null) {
      // build AND ExpressionNode tree, e.g. 3 < x && x < 7
        left = andList.get(0);
        for (int i=1; i < andList.size(); i++) {
      left = new ExpressionNode(kernel, left, Operation.AND_INTERVAL, andList.get(i));
        }   
      }
      return left;
    }  
}

/**
 *  expression =    term + term |
 *                  term - term
 */
ExpressionValue plusminusnode():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = multterm()                 
    (( x = <PLUS> | x = <MINUS> ) f = multterm()
        {                       
            if (x.kind == PLUS) 
                ret = new ExpressionNode(kernel, ret, Operation.PLUS, f);  
            else            {              if(ret.isExpressionNode() && ( (ExpressionNode)ret).isStringAddition() )              {                ((ExpressionNode) ret).setRight(new ExpressionNode(kernel,
							((ExpressionNode) ret).getRight(), Operation.MINUS,
							f));
              }
              else              {
                 ret = new ExpressionNode(kernel, ret, Operation.MINUS, f);              }
        	}
      }          
    )*
    { 
      //ret.simplifyLeafs();
      return ret; 
    }
}

ExpressionValue sequencenode():
{
    ExpressionValue ret, f;
}
{
    ret = plusminusnode()                 
    (<SEQUENCE_OPERATOR> f = plusminusnode()
        {                       
            ret = new ExpressionNode(kernel, ret, Operation.SEQUENCE, f);  
        }
    )*
    { 
      //ret.simplifyLeafs();
      return ret; 
    }
}

ExpressionValue setdifferencenode():
{
    ExpressionValue ret, f;
}
{
    ret = sequencenode()                 
    (<SET_DIFFERENCE> f = sequencenode()
        {                       
            ret = new ExpressionNode(kernel, ret, Operation.SET_DIFFERENCE, f);  
        }
    )*
    { 
      //ret.simplifyLeafs();
      return ret; 
    }
}

ExpressionValue listopnode():
{
    ExpressionValue ret, f;
}
{
    ret = setdifferencenode()                 
    (<IS_ELEMENT_OF> f = setdifferencenode()
        {                       
            ret = new ExpressionNode(kernel, ret, Operation.IS_ELEMENT_OF, f);  
        }
    )?
    { 
      //ret.simplifyLeafs();
      return ret; 
    }
}

/**
 * multterm =   divterm * divterm 
 */
ExpressionValue multterm():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = divterm()           
    (                 
     ( x = <MULTIPLY> | x = <VECTORPRODUCT> ) f = divterm() 
        {
            if (x.kind == MULTIPLY) {
                ret = new ExpressionNode(kernel, ret, Operation.MULTIPLY, f);   
            } else {
                ret = new ExpressionNode(kernel, ret, Operation.VECTORPRODUCT, f);  
            }
        }
     |
     // We do not want to accept | here because it may lead to confusing opening and closing abs bars
     LOOKAHEAD( { getToken(1).kind != VERTICAL_BAR} )
     f = powerdivterm()
        {
              ExpressionValue special = ExpressionNode.multiplySpecial(ret, f, kernel, GiacParsing);
  
                  if(special == null)
                  {
                      ret = new ExpressionNode(kernel, ret, Operation.MULTIPLY, f);
                  }else {
                  	  ret = special;
                  }
            }
           
    )*
    { return ret; }  
}

/**
 * divterm =  unary / unary
 */
ExpressionValue divterm():
{
    ExpressionValue ret, f;
}
{
    ret = enunary()           
    (                 
       <DIVIDE> f = enunary() 
        {
            ret = new ExpressionNode(kernel, ret, Operation.DIVIDE, f); 
        }  
    )*
    { return ret; }  
}

/**
 * powerdivterm =  power / unary
 */
ExpressionValue powerdivterm():
{
    ExpressionValue ret, f;
}
{
    ret = enpower()           
    (                 
       <DIVIDE> f = enunary() 
        {
            ret = new ExpressionNode(kernel, ret, Operation.DIVIDE, f); 
        }  
    )*
    { return ret; }  
}

/**
 * unary =  -power    |
 *           +power    |   
 *          power
 */
ExpressionValue enunary():        
{
    ExpressionValue e;
}
{
    <MINUS> e = enpower()
        { // -e  = -1*e
          return ExpressionNode.unaryMinus(kernel, e);              
        }
|
   <PLUS> e = enpower()
        { // +e  = e
          return e;              
        }
|
    e = enpower()
        {
            return e;
        }
}

/**
 * power =    element                 |
 *          element ^ power           
 */
ExpressionValue enpower():
{
    ExpressionValue ret, f;
    Token c = null;
    ArrayList<ExpressionValue> exponentList = null;
    
}
{  
    ret = enfactorial()         
    (
        (   
       c = <POWERN> 
        {            
            f = new MyDouble(kernel, c.image);
            // collect exponents
      if (exponentList == null)
        exponentList = new ArrayList<ExpressionValue>();
            exponentList.add(f);  
      }
     )     
    |                   
      (
          <POWER> (c = <MINUS> | c = <PLUS>)? f = enfactorial()
        {
            // -f  = -1*f
      if (c != null && c.kind == MINUS)
      {                
             f = ExpressionNode.unaryMinus(kernel, f);
             c = null; // make sure we forget minus for next exponent
            }
          
      // collect exponents
      if (exponentList == null)
        exponentList = new ArrayList<ExpressionValue>();
            exponentList.add(f);  

           /*
          // check if we have e^
          if (ret.isExpressionNode()) {
            ExpressionNode en = (ExpressionNode) ret;
            if (en.isLeaf() &&  en.getLeft() instanceof MyDouble) {
              MyDouble num = (MyDouble) en.getLeft();
              if (num.getDouble() == Math.E) {        
                  ret = new ExpressionNode(kernel, f, Operation.EXP, null);            
              } 
            }       
          }
      */                                            
        }
        )                       
    )*
    {
    if (exponentList == null)
      return ret;
      
        
      // GeoGebra / Giac etc : right associative: a^b^c = a^(b^c)
      int size = exponentList.size();
      ExpressionValue tempEV = exponentList.get(size-1); // last exponent, e.g. c
      for (int i=size-2; i >= 0; i--)
    {
      ExpressionValue prevExponent = exponentList.get(i);
      tempEV = makePower(prevExponent,tempEV);
    }
    ret = makePower(ret, tempEV);
  
        return ret;

      }    
}

/**
 * factorial =  <NOTterm> |
 *              <NOTterm> !
 */
ExpressionValue enfactorial():
{   
    ExpressionValue en;   
}
{     
      en = ensqrt() 
      (LOOKAHEAD(<FACTORIAL>) <FACTORIAL> 
       {
             if(en.isExpressionNode() && ((ExpressionNode)en).getOperation()==Operation.MULTIPLY_OR_FUNCTION
             && !((ExpressionNode)en).hasBrackets())
             {
               en = new ExpressionNode(kernel, ((ExpressionNode)en).getLeft(),
                 Operation.MULTIPLY,
                 new ExpressionNode(kernel, ((ExpressionNode)en).getRight(), Operation.FACTORIAL, null)
                 );
             }
             else
              en = new ExpressionNode(kernel, en, Operation.FACTORIAL, null);                    
       }      
       )?    
       { return en; }        
}

ExpressionValue ensqrt():
{   
    ExpressionValue en;   
}
{     
      <SQRT_SHORT > en = NOTterm()  
       {
             if(en.isExpressionNode() && ((ExpressionNode)en).getOperation()==Operation.MULTIPLY_OR_FUNCTION
             && !((ExpressionNode)en).hasBrackets())
             {
               en = new ExpressionNode(kernel,
               new ExpressionNode(kernel, ((ExpressionNode)en).getLeft(), Operation.SQRT_SHORT, null),
                 Operation.MULTIPLY,
               ((ExpressionNode)en).getRight()  
                 );
             }
             else
              en = new ExpressionNode(kernel, en, Operation.SQRT_SHORT, null);
              return en;               
       }     | en = NOTterm() 
           
       { return en; }
       { return en; }  
}

/**
 * NOTterm =  <NOT> <enelement> |
 *                 <enelement>
 */
ExpressionValue NOTterm():
{   
    ExpressionValue en;   
}
{     
  (
      ( <NOT> | "!" ) en = enelement()       
       {            
              return new ExpressionNode(kernel, en, Operation.NOT, null);       
       }      
   ) 
|
   (
      en = enelement()   
       { return en; }        
   )             
}

/**
 * element =    <variable>      |
 *              <float>         |
 *              ( expression )
 */
ExpressionValue enelement():
{    
    ExpressionValue ev;
    Token c;    
}
{   
// boolean
  <TRUE>
   { return  new MyBoolean(kernel, true); }     
|
  <FALSE>
    { return new MyBoolean(kernel, false); }     
|      
 // number
    ev = myDouble()
        { return ev; }      
|
    // cos, sin, tan, ...
    LOOKAHEAD(2147483647)
    ev = numberFunction()
         { return ev; }
|
  // command
  LOOKAHEAD(2147483647)
    ev = command()
        { return ev; } 
|
    // number or vector variable
     LOOKAHEAD(2147483647)
    ev = numVecVariable()
        { return ev; }
|        
    //list
    LOOKAHEAD(2147483647)
  ev = list()
      { return ev; }      
| 
     
    // absolute value
    LOOKAHEAD(2147483647)
    <VERTICAL_BAR> ev = expressionnode() <VERTICAL_BAR> 
        { 
			return new ExpressionNode(kernel, ev, Operation.ABS, null);
		}
|
    // cartesian vector  (x, y) or (x|y)
    LOOKAHEAD(2147483647)
    ev = tuple()
        { return ev; } 
 |

  // text (between " ... ")
  c = <TEXT>
    { 
      // remove " (first and last character)
      String text = c.image.substring(1, c.image.length()-1);
      return  new MyStringBuffer(kernel, text);
     }  
}

ExpressionValue list():
{
    MyList myList;
    ExpressionValue ev;
}
{
   "{" 
 (   (
     // empty list
       "}"  
      {   
           return ifVectorsEnabled(new MyList(kernel));               
       }
    )
    |
   ( 
    // list    
      ev = expressionOrEquation()     
       {   
            myList = new MyList(kernel);         
            myList.addListElement(ev);
        }
       ( <COMMA> ev = expressionOrEquation()  
          {
           myList.addListElement(ev); 
          } 
        )*
    "}"
    {  return ifVectorsEnabled(myList);  }
   )
 )
  
}

ExpressionValue numVecVariable():
{
    Token c;
    ExpressionValue ev;
}
{
    c = <VARX>  
    {
      
        if (GeoGebraCASParsing)
       return new Variable(kernel, c.image);
    else    
          return new FunctionVariable(kernel, c.image);
    }
|
    c = <VARY>  
    {
        if (GeoGebraCASParsing)
       return new Variable(kernel, c.image);
    else
          return new FunctionVariable(kernel, c.image);
    }
|
    c = <VARZ>  
    {
        // check for CAS parsing or if z is defined in kernel
        if (GeoGebraCASParsing || kernel.lookupLabel("z") != null) {
       return new Variable(kernel, c.image);
    } else {
       // z is not defined: treat as equation variable for 3D view
        return new FunctionVariable(kernel, c.image);
       }
    }
|
  // spreadsheet range like A1:B2
  LOOKAHEAD (3)
  ev = spreadsheetRange()
  {
    return ev;
  }
|
    ( c = <SPREADSHEET_LABEL> | c = <LABEL> )
    {
        // should we read e for Euler constant and i for imaginary unit?
    boolean lookforEulerImaginary = false;

    if (GeoGebraCASParsing)
    {
        // leave e and i untouched in GeoGebraCAS view
        lookforEulerImaginary = false;
    }
    else if (ExternalCASParsing)
    {  // Giac does not need it either, may need changing for other CASes
        lookforEulerImaginary = false;
    }
    else
    {   // GeoGebraCAS or GeoGebra parsing
      // only treat e or i specially when they are undefined in GeoGebra
      lookforEulerImaginary = true;
    }
      
        // return defined variables immediately
    if (lookforEulerImaginary)
    {
      // TREAT e and i specially
      // e for Euler constant
      if (c.image.equals("e") && kernel.lookupLabel(c.image) == null)
      {     
        return kernel.getEulerNumber();
      }
      // i for imaginary unit
      else if (c.image.equals("i") && kernel.lookupLabel(c.image) == null)
      {
          return kernel.getImaginaryUnit();
      }
    }              

       // standard case for variables
       return new Variable(kernel, c.image);
    }
}


/**
 * spreadsheet range, e.g. A3:B5
 */
Command spreadsheetRange():
{
    Token c, c2;
}
{
  // spreadsheet range like A1:B2
  c = <SPREADSHEET_LABEL> ":" c2 = <SPREADSHEET_LABEL>
  {
    // build command CellRange[ startCell, endCell ]
    ExpressionNode startCell = new ExpressionNode(kernel, new Variable(kernel, c.image));
    ExpressionNode endCell = new ExpressionNode(kernel, new Variable(kernel, c2.image));
    Command cmd = new Command(kernel, "CellRange", false, !ExternalCASParsing ); // don't translate name
    cmd.addArgument(startCell);
    cmd.addArgument(endCell);
    return cmd;
  }
}
   

/**
 * floating point number: angle or numeric are distinguished
 */
ExpressionValue myDouble():
{
    Token c;
    Token percent = null;
    MyDouble d;
    double val;
}
{       
   (
     (c = <FLOAT> | c = <EFLOAT>)(percent ="%")?
      {
      // check if token includes "b"
        
          c.image = c.image.replaceFirst("e", "E" );
        val = MyDouble.parseDouble( loc, c.image );
        if(percent != null) { 
	 	                        val = val * 0.01; 
	 	} 
        
 } 

    )
  {
      if (ExternalCASParsing || GeoGebraCASParsing) {
        // preserve string from CAS: it may have higher
        // precision than double
        
           return new MySpecialDouble(kernel, val, percent == null ? c.image : c.image + "%");  
      }
      else {
          return new MyDouble(kernel, val);
      }                               
    }
|
    (c = <DEGREE>)
    {  // constant for degree to radians
    if(c.image.length() ==3)    {		GeoElement geo = kernel.lookupLabel(c.image);
		if(geo != null)		{			return geo;
		}
    } 
        d = new MySpecialDouble(kernel, Math.PI / 180.0d, "\u00b0");
        d.setAngle();
        return d;
    }
|
    <RAD>
    {  // constant for radians to radians 
        d = new MySpecialDouble(kernel, 1.0d, "rad");
        d.setAngle();
        return d;
    }
|
    <GRADIAN>
    {  // constant for gradians to radians 
        d = new MySpecialDouble(kernel, Math.PI / 200.0d, "\u1D4D");
        d.setAngle();
        return d;
    }
|
    <PI>
    {
         return new MySpecialDouble(kernel, Math.PI, Unicode.PI_STRING);
    }
|
    <EULER_GAMMA>
    {	
         return new MySpecialDouble(kernel, 0.57721566490153286, Unicode.EULER_GAMMA_STRING);
    }
|
    <E>
    {    
      return kernel.getEulerNumber();
    }
|
   <IMAGINARY>
    {
      return kernel.getImaginaryUnit();
    }         
 |
    <INFINITY>
    {
        return new MyDouble(kernel, Double.POSITIVE_INFINITY);
    }   
|
  <UNDEFINED>
  {
        return new MyDouble(kernel, Double.NaN);
    }
}


/**
 * mathematical Function (cos, sin, tan, ...)
 */
ExpressionNode numberFunction():
{
    ValidExpression en;
    MyList myList;
    Token c;
}
{           
    c = <X_FUNC> en = expressionOrEquation() (")"|"]")
      {
        if (GeoGebraCASParsing) 
        {            
      		return Command.xyzCAS(en, 0,!ExternalCASParsing, undecided);
        }
        else
        {
          // standard GeoGebra input bar: x(...) is interpreted as "x-coordinate of"
          return new ExpressionNode(kernel, en, Operation.XCOORD, null);
        }
       }  
|
     c = <Y_FUNC> en = expressionOrEquation() (")"|"]")
      {
        if (GeoGebraCASParsing) 
        {
            // GeoGebra CAS view: y(...) is interpreted as a function
            return Command.xyzCAS(en, 1,!ExternalCASParsing, undecided);
        }
        else
        {
          // standard GeoGebra input bar: y(...) is interpreted as "y-coordinate of"
          return new ExpressionNode(kernel, en, Operation.YCOORD, null);
        }
       } 
|
     c = <Z_FUNC> en = expressionOrEquation() (")"|"]")
     {
        if (GeoGebraCASParsing) 
        {
            return Command.xyzCAS(en,2,!ExternalCASParsing, undecided);
        }
        else
        {
            // standard GeoGebra input bar: z(...) is interpreted as user function z or "z-coordinate of"
              GeoElement userFun = kernel.lookupLabel("z");
       if (userFun instanceof Evaluatable) {
          // user defined function z
        return new ExpressionNode(kernel, userFun, Operation.FUNCTION, en);
            } else {
         // internal function z
        return new ExpressionNode(kernel, en, Operation.ZCOORD, null);
           }
        }
      }
| 
      ( c = <FUNCTION_POWER_LABEL> ) en = expressionOrEquation() (")"|"]") 
           {
             int pos = c.image.length()-2;
             while(pos >=0 && (Unicode.isSuperscriptDigit(c.image.charAt(pos))||
             Unicode.Superscript_Minus==c.image.charAt(pos))){
               pos--;
             }
             ExpressionNode ret = kernel.handleTrigPower(c.image, en, c.image.substring(0,pos+1));
             if(ret.getOperation()==Operation.MULTIPLY_OR_FUNCTION)
               undecided.add(ret);
             return ret;
             }          
|      <RANDOM_FUNC>
      {  
         Construction cons = kernel.getConstruction();
         GeoNumeric randNum = new GeoNumeric(cons);
         cons.addRandomGeo(randNum);
         randNum.setValue(app.getRandomNumber());         
         return new ExpressionNode(kernel, randNum, Operation.RANDOM, null);
      }
|
  (
    c = <FUNCTION_LABEL> en = expressionOrEquation()
    {   
            myList = new MyList(kernel, true);         
            myList.addListElement(en);
        }
       ( <COMMA> en = expressionOrEquation()  
          {
           myList.addListElement(en); 
          } 
        )*
    )
  (")"|"]")
  // note: the last character of FUNCTION_LABEL is a "("
      { 
          // remove the opening parenthesis
          return functionParser.makeFunctionNode(c.image,myList, undecided, GiacParsing);
      }  
}




/**
 *  tuple =  ( expression, expression )
 *  tuple =  ( expression, expression, expression )
 * | and ; can be used instead of , 
 */
ExpressionValue tuple():
{     
    ExpressionValue x, y=null, z = null;
    Token sep = null;            
}
{   
    // cartesian coordinates
  
    "(" x = expressionOrEquation() (  
   		(   sep = <COMMA> y = expressionOrEquation() (<COMMA> z = expressionnode())?   )   
    	|   (  sep = <VERTICAL_BAR> y = expressionOrEquation() (<VERTICAL_BAR> z = expressionnode())? )
    	|  (  sep = <POLAR_SEPARATOR> y = expressionOrEquation() (<POLAR_SEPARATOR> z = expressionnode())?  )
		)? ")"
    {
      
      if(y == null)      {
        
         if(GiacParsing)
        {
          x = x.unwrap();
        }
         if(x instanceof ExpressionNode)
        {
          ((ExpressionNode)x).setBrackets(true);
        }
        return x;      }
      else if(z == null) {       	       MyVecNode ret = new MyVecNode(kernel, x, y);
	       if(sep.kind == POLAR_SEPARATOR){
	             ret.setPolarCoords(x,y);	       }
	       return ifVectorsEnabled(ret);      }      else {                 MyVec3DNode ret = new MyVec3DNode(kernel, x, y, z);
          if(sep.kind == POLAR_SEPARATOR){
             ret.setSphericalPolarCoords(x,y,z);
           }
           return ifVectorsEnabled(ret);
       }
    }       
}



/**
 * cartesianvector_special =  <LABEL>( expression | expression ) 
 */
ExpressionNode cartesianvector_special():
{     
   Token l;
    ExpressionValue x, y;                
}
{   
    // cartesian coordinates
    (   l = <FUNCTION_LABEL>  x = expressionNoFreeVars() <VERTICAL_BAR> y = expressionNoFreeVars() ")" )
        {
          if(!enableVectors)
      {
        return new ExpressionNode(kernel, Double.NaN);
      }        
          ExpressionNode en =  new ExpressionNode(kernel, new MyVecNode(kernel, x, y)); 
          en.setLabel(l.image.substring(0,l.image.length()-1));
          return en;
        }           
}

ExpressionNode cartesianvector3D_special():
{     
   Token l;
    ExpressionValue x, y, z;                
}
{   
    // cartesian coordinates
    (   l = <FUNCTION_LABEL>  x = expressionNoFreeVars() <VERTICAL_BAR > y = expressionNoFreeVars() <VERTICAL_BAR> z = expressionNoFreeVars() ")" )
        {
          if(!enableVectors)
      {
        return new ExpressionNode(kernel, Double.NaN);
      }        
          ExpressionNode en =  new ExpressionNode(kernel, new MyVec3DNode(kernel, x, y, z)); 
          en.setLabel(l.image.substring(0,l.image.length()-1));
          return en;
        }           
}

/**
 * polarvector_special =  <LABEL>( expression ; expression ) 
 */
ExpressionNode polarvector_special():
{     
   Token l;
    ExpressionValue r, phi;                
}
{   
    // cartesian coordinates
    (   l = <FUNCTION_LABEL>  r = expressionNoFreeVars() <POLAR_SEPARATOR>  phi = expressionNoFreeVars() ")" )
        {
          if(!enableVectors)
      {
        return new ExpressionNode(kernel, Double.NaN);
      }      
            MyVecNode v = new MyVecNode(kernel);
            v.setPolarCoords(r, phi);
          ExpressionNode en =  new ExpressionNode(kernel, v); 
          en.setLabel(l.image.substring(0,l.image.length()-1));
          return en;
        }           
}



