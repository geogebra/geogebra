/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.utils;import java.util.Iterator;
public class IntList implements Iterable<Integer> {	public int ints[] = null;	public int num = 0;	private int growBy = 0;	public IntList() {		this(0, 0);	}	public IntList(int size) {		this(size, 0);	}	public IntList(int size, int growBy) {		this.growBy = growBy;		ints = new int[size];	}	public IntList(int[] theInts) {		this(theInts, theInts.length);	}	public IntList(int[] theInts, int length) {		this(length, 0);		System.arraycopy(theInts, 0, ints, 0, length);		num = length;	}	public void addBoolean(boolean b) {		add(b ? 1 : 0);	}	public void add(int o) {		if (num >= ints.length && growBy > 0) {			int[] temp = new int[ints.length + growBy];			System.arraycopy(ints, 0, temp, 0, num);			ints = temp;		}		ints[num] = o;		++num;	}	public void setSize(int s) {		if(s > ints.length){			int[] temp = new int[s];			System.arraycopy(ints, 0, temp, 0, num);			ints = temp;		}		num = s;	}	void insert(int i, int o) {		System.arraycopy(ints, i, ints, i + 1, num - i);		ints[i] = o;		++num;	}	void remove(int o) {		remove(find(o));	}	void removeIndex(int first, int last) {		System.arraycopy(ints, last + 1, ints, first, num - last - 1);		num -= last - first + 1;	}	public int removeIndex(int i) {		int removed = ints[i];		--num;		ints[i] = ints[num];		return removed;	}	public int orderedRemoveIndex(int i) {		int removed = ints[i];		if (i >= 0 && i < num - 1) {			System.arraycopy(ints, i + 1, ints, i, num - i - 1);		}		--num;		return removed;	}	public int get(int i) {		if (i >= num) {			throw new ArrayIndexOutOfBoundsException(i);		}		return ints[i];	}	public boolean getBoolean(int i) {		return ints[i] != 0;	}	public int wrapget(int i) {		return get(indexToRange(i));	}	int getLast() {		return ints[num - 1];	}	public void set(int i, int o) {		ints[i] = o;	}	public int find(int o) {		for (int i = 0; i < num; ++i) {			if (ints[i] == o)				return i;		}		return -1;	}	int findAfterIndex(int o, int index) {		for (int i = index + 1; i < num; ++i) {			if (ints[i] == o)				return i;		}		return -1;	}	public void reverse() {		for (int i = 0, j = num - 1; i < j; ++i, --j) {			int temp = ints[i];			ints[i] = ints[j];			ints[j] = temp;		}	}	IntList copy(IntList ol) {		System.arraycopy(ints, 0, ol.ints, 0, num);		ol.num = num;		return ol;	}	public IntList copy() {		IntList ol = new IntList(ints.length);		System.arraycopy(ints, 0, ol.ints, 0, num);		ol.num = num;		return ol;	}	public IntList shrinkCopy() {		IntList ol = new IntList(num);		System.arraycopy(ints, 0, ol.ints, 0, num);		ol.num = num;		return ol;	}	public IntList wrapCopy(int start, int inc) {		IntList ol = new IntList(ints.length);		for (int i = 0, j = start; i < num; ++i, j += inc) {			ol.ints[i] = wrapget(j);		}		ol.num = num;		return ol;	}	public IntList shrink() {		if (ints.length > num) {			int[] temp = new int[num];			System.arraycopy(ints, 0, temp, 0, num);			ints = temp;		}		return this;	}	public int indexToRange(int i) {		while (i < 0)			i += num;		return i % num;	}	public IntList intersect(IntList other) {		IntList sect = new IntList(5, 5);		for (int i : other) {			if (find(i) >= 0) {				sect.add(i);			}		}		return sect;	}	public int length() {		return ints.length;	}	public int removeDuplicates() {		int count = 0;		for (int i = 0; i < num; ++i) {			for (int j = i + 1; j < num; ++j) {				if (ints[j] == ints[i]) {					removeIndex(j);					--j;					++count;				}			}		}		return count;	}	public int orderedRemoveDuplicates() {		int count = 0;		for (int i = 0; i < num; ++i) {			for (int j = i + 1; j < num; ++j) {				if (ints[j] == ints[i]) {					orderedRemoveIndex(j);					--j;					++count;				}			}		}		return count;	}	static void quickSort(int[] array, int first, int last) {		int low = first;		int high = last;		if (first >= last)			return;		int mid = array[(first + last) / 2];		do {			while (array[low] < mid)				++low;			while (array[high] > mid)				--high;			if (low <= high) {				int temp = array[low];				array[low++] = array[high];				array[high--] = temp;			}		} while (low <= high);		quickSort(array, first, high);		quickSort(array, low, last);	}	public void sort() {		quickSort(ints, 0, num - 1);	}	public int size() {		return num;	}	public String toString() {		StringBuffer buf = new StringBuffer("(");		for (int i = 0; i < num; ++i) {			buf.append(ints[i]);			if (i < num - 1) {				buf.append(", ");			}		}		buf.append(")");		return buf.toString();	}	public boolean isEmpty() {		return num == 0;	}	public void clear() {		num = 0;	}	public int[] toArray() {		int[] array = new int[num];		System.arraycopy(ints, 0, array, 0, num);		return array;	}	public Iterator<Integer> iterator() {		return new Iterator<Integer>() {			int index = 0;			public boolean hasNext() {				return ints.length > index && num > index;			}			public Integer next() {				return ints[index++];			}			public void remove() {				orderedRemoveIndex(index - 1);			}		};	}}