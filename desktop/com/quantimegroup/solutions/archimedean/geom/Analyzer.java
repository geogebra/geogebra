/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.geom;import com.quantimegroup.solutions.archimedean.utils.Axes;
import com.quantimegroup.solutions.archimedean.utils.IntList;
import com.quantimegroup.solutions.archimedean.utils.ObjectList;
import com.quantimegroup.solutions.archimedean.utils.OrderedTriple;
import com.quantimegroup.solutions.archimedean.utils.Rotater;
public class Analyzer {	private ObjectList<int[]> cornerTabulation, sideTabulation;	private ObjectList<AxisData> cornerAxes, sideAxes, edgeAxes;	private ObjectList<ArchiFacet> savePolySides;	private int numAxesOfSymmetry = 0;	private IntList oldSideList = new IntList(0);	public Analyzer() {	}	static boolean isAxisOfSymmetry(OrderedTriple p, int fold, ArchiBuilder b) {		ObjectList<OrderedTriple> points = new ObjectList<OrderedTriple>(b.getPointCount());		for (int i = 0; i < b.getPointCount(); ++i) {			points.add(new OrderedTriple(b.getPoint(i)));		}		Rotater r = new Rotater(p, Math.PI * 2 / fold);		Axes a = new Axes();		a.timesEquals(r);		ObjectList<OrderedTriple> copiedPoints = b.getPoints().copy();		for (int i = 0; i < points.num; ++i) {			OrderedTriple pi = (OrderedTriple) points.get(i);			a.transformPoint(pi);			int found = ArchiBuilder.findApproxPoint(pi, copiedPoints);			if (found == -1)				return false;			else				copiedPoints.removeIndex(found);		}		return copiedPoints.num == 0;	}	static IntList[] getSideData(ArchiBuilder b) {		IntList irregularSides = new IntList(0, 10);		IntList regularSides = new IntList(0, 10);		for (int i = 0; i < b.getSideCount(); ++i) {			ArchiFacet s = b.getSide(i);			IntList curTable = s.isREGULAR() ? regularSides : irregularSides;			int n = s.getVertexCount();			if (n >= curTable.length()) {				curTable.setSize(n + 1);				curTable.num = n + 1;			}			curTable.set(n, curTable.get(n) + 1);		}		IntList[] table = {				regularSides, irregularSides };		return table;	}	static IntList getCornerData(ArchiBuilder b) {		IntList table = new IntList(0, 10);		for (int i = 0; i < b.getCornerCount(); ++i) {			ArchiCorner c = b.getCorner(i);			int n = c.getSpokes().num;			if (n >= table.length()) {				table.setSize(n + 1);				table.num = n + 1;			}			table.set(n, table.get(n) + 1);		}		return table;	}	static int[] getSideSignature(ArchiFacet s, ArchiBuilder b) {		ObjectList<ArchiFacet> adjacentSides = new ObjectList<ArchiFacet>(s.getVertexCount());		for (int i = 0; i < b.getSideCount(); ++i) {			ArchiFacet si = b.getSide(i);			if (si == s)				continue;			if (si.isAdjacent(s))				adjacentSides.add(si);		}		int[] sign = new int[s.getVertexCount()];		int index = 0;		while (adjacentSides.num > 0) {			for (int i = 0; i < adjacentSides.num; ++i) {				ArchiFacet si = (ArchiFacet) adjacentSides.get(i);				if (si.findIndex(s.getIndex(index)) != -1 && si.findIndex(s.wrapgetIndex(index + 1)) != -1) {					sign[index] = si.getVertexCount();					index++;					adjacentSides.removeIndex(i);					break;				}			}		}		return sign;	}	static boolean pat(int[] sign, int patLen) {		for (int i = 0; i < patLen; ++i) {			for (int j = 0; i + (j + 1) * patLen < sign.length; ++j) {				if (sign[i + j * patLen] != sign[i + (j + 1) * patLen])					return false;			}		}		return true;	}	static int getPattern(int[] sign) {		for (int i = 1; i <= (sign.length + 1) / 2; ++i) {			if (sign.length % i == 0 && pat(sign, i))				return i;		}		return -1;	}	void findRotationalAxes(ArchiBuilder b) {		numAxesOfSymmetry = 0;		cornerAxes = new ObjectList<AxisData>(b.getCornerCount());		sideAxes = new ObjectList<AxisData>(b.getSideCount());		edgeAxes = new ObjectList<AxisData>(b.numEdges());		ObjectList<OrderedTriple> cornerUnits = new ObjectList<OrderedTriple>(b.getCornerCount());		ObjectList<OrderedTriple> sideUnits = new ObjectList<OrderedTriple>(b.getSideCount());		ObjectList<OrderedTriple> edgeUnits = new ObjectList<OrderedTriple>(b.numEdges());		ObjectList<OrderedTriple> badUnits = new ObjectList<OrderedTriple>(0, 10);		for (int i = 0; i < b.getCornerCount(); ++i) {			ArchiCorner c = b.getCorner(i);			OrderedTriple p = c.getHubPoint();			if (ArchiBuilder.findApproxPoint(p.unit(), badUnits) != -1)				continue;			int foundCorner = ArchiBuilder.findApproxPoint(p.unit().negative(), cornerUnits);			if (foundCorner != -1) {				getAxis(cornerAxes, foundCorner).point2 = p;				continue;			}			int foundSide = ArchiBuilder.findApproxPoint(p.unit().negative(), sideUnits);			if (foundSide != -1) {				AxisData foundAxis = getAxis(sideAxes, foundSide);				cornerAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));				foundAxis.point2 = p;				cornerUnits.add(p.unit());				continue;			}			int foundEdge = ArchiBuilder.findApproxPoint(p.unit().negative(), edgeUnits);			if (foundEdge != -1) {				AxisData foundAxis = getAxis(edgeAxes, foundEdge);				cornerAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));				foundAxis.point2 = p;				cornerUnits.add(p.unit());				continue;			}			for (int fold = c.getSpokes().num; fold >= 2; --fold) {				if (c.getSpokes().num % fold != 0)					continue;				if (isAxisOfSymmetry(p, fold, b)) {					cornerAxes.add(new AxisData(p, null, fold));					cornerUnits.add(p.unit());					numAxesOfSymmetry++;					break;				} else {					badUnits.add(p.unit());				}			}		}		for (int i = 0; i < b.getSideCount(); ++i) {			double epsilon = 1e-2;			ArchiFacet s = b.getSide(i);			OrderedTriple p = s.getIncenter();			if (p.length() < epsilon) {				continue;			}			if (ArchiBuilder.findApproxPoint(p.unit(), badUnits) != -1)				continue;			int foundSide = ArchiBuilder.findApproxPoint(p.unit().negative(), sideUnits);			if (foundSide != -1) {				getAxis(sideAxes, foundSide).point2 = p;				continue;			}			int foundCorner = ArchiBuilder.findApproxPoint(p.unit().negative(), cornerUnits);			if (foundCorner != -1) {				AxisData foundAxis = getAxis(cornerAxes, foundCorner);				sideAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));				foundAxis.point2 = p;				sideUnits.add(p.unit());				continue;			}			int foundEdge = ArchiBuilder.findApproxPoint(p.unit().negative(), edgeUnits);			if (foundEdge != -1) {				AxisData foundAxis = getAxis(edgeAxes, foundEdge);				sideAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));				foundAxis.point2 = p;				sideUnits.add(p.unit());				continue;			}			for (int fold = s.getVertexCount(); fold >= 2; --fold) {				if (s.getVertexCount() % fold != 0)					continue;				if (isAxisOfSymmetry(p, fold, b)) {					sideAxes.add(new AxisData(p, null, fold));					sideUnits.add(p.unit());					numAxesOfSymmetry++;					break;				} else {					badUnits.add(p.unit());				}			}		}		for (int i = 0; i < b.getCornerCount(); ++i) {			ArchiCorner c = b.getCorner(i);			for (int j = 0; j < c.getSpokes().num; ++j) {				if (c.getSpokes().get(j) < c.getHub())					continue;				OrderedTriple p = c.getHubPoint().mid(c.getSpoke(j));				if (ArchiBuilder.findApproxPoint(p.unit(), badUnits) != -1)					continue;				int foundEdge = ArchiBuilder.findApproxPoint(p.unit().negative(), edgeUnits);				if (foundEdge != -1) {					getAxis(edgeAxes, foundEdge).point2 = p;					continue;				}				int foundCorner = ArchiBuilder.findApproxPoint(p.unit().negative(), cornerUnits);				if (foundCorner != -1) {					AxisData foundAxis = getAxis(cornerAxes, foundCorner);					edgeAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));					foundAxis.point2 = p;					edgeUnits.add(p.unit());					continue;				}				int foundSide = ArchiBuilder.findApproxPoint(p.unit().negative(), sideUnits);				if (foundSide != -1) {					AxisData foundAxis = getAxis(sideAxes, foundSide);					edgeAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));					foundAxis.point2 = p;					edgeUnits.add(p.unit());					continue;				}				if (isAxisOfSymmetry(p, 2, b)) {					edgeAxes.add(new AxisData(p, null, 2));					edgeUnits.add(p.unit());					numAxesOfSymmetry++;				} else {					badUnits.add(p.unit());				}			}		}		cornerTabulation = new ObjectList<int[]>(100);		tabulateAxes(cornerAxes, cornerTabulation);		sideTabulation = new ObjectList<int[]>(100);		tabulateAxes(sideAxes, sideTabulation);	}	void tabulateAxes(ObjectList<AxisData> theAxes, ObjectList<int[]> theTabs) {		int[] tab = new int[100];		int maxFold = 0;		for (int i = 0; i < theAxes.num; ++i) {			int fold = getAxis(theAxes, i).fold;			tab[fold]++;			if (fold > maxFold)				maxFold = fold;		}		for (int i = 0; i < maxFold + 1; ++i) {			if (tab[i] > 0) {				int[] item = {						i, tab[i] };				theTabs.add(item);			}		}	}	double getSurfaceArea(ArchiBuilder b) {		double surfaceArea = 0;		for (int i = 0; i < b.getSideCount(); ++i) {			surfaceArea += b.getSide(i).getArea();		}		return surfaceArea;	}	double getPyramidVolume(ArchiFacet s, OrderedTriple tip) {		OrderedTriple[] p = GeometryUtils.threeDistinctPoints(s);		return OrderedTriple.pointPlaneDistance(tip, p[0], p[1], p[2]) * s.getArea() / 3;	}	double getVolume(ArchiBuilder b) {		double volume = 0;		for (int i = 0; i < b.getSideCount(); ++i) {			volume += getPyramidVolume(b.getSide(i), OrderedTriple.origin());		}		return volume;	}	double getSurfaceVolumeQuotient(ArchiBuilder b) {		double r = Math.sqrt(getSurfaceArea(b) / (4 * Math.PI));		double surfaceVolumeQuotient = (getSurfaceArea(b) * r) / (getVolume(b) * 3);		return surfaceVolumeQuotient;	}	void showAllCorners() {	}	void showCorners() {	}	void showSides() {	}	void analyzer_ListSelect() {	}	int getFold(String s) {		int dashi = s.indexOf('-');		int tens = 1;		char c;		int fold = 0;		while (--dashi >= 0) {			c = s.charAt(dashi);			if (Character.isDigit(c)) {				fold += tens * (c - '0');				tens *= 10;			} else				break;		}		return fold;	}	ObjectList<ArchiFacet> makeSideList(ObjectList<ArchiFacet> sides, int numPoints, boolean regular) {		ObjectList<ArchiFacet> newSides = new ObjectList<ArchiFacet>(sides.num);		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = (ArchiFacet) sides.get(i);			if (s.isREGULAR() == regular && s.getVertexCount() == numPoints) {				newSides.add(savePolySides.get(oldSideList.get(i)));			}		}		return newSides;	}	IntList makeCornerList(ArchiBuilder builder, ObjectList<ArchiCorner> corners, int numSpokes) {		IntList newCorners = new IntList(corners.num);		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = (ArchiCorner) corners.get(i);			if (c.getSpokes().num == numSpokes) {				int found = ArchiBuilder.findApproxPoint(c.getHubPoint(), builder.getPoints());				if (found == -1)					System.out.println("makeCornerList");				else					newCorners.add(found);			}		}		return newCorners;	}	IntList makeCornerList() {		return null;	}	static String polygonName(int i, boolean regular) {		String[] polygonNames = {				"", "", "", "Triangle", "Square", "Pentagon", "Hexagon", "Heptagon", "Octagon", "Nonagon", "Decagon", "Undecagon", "Dodecagon" };		if (i == 3) {			if (regular)				return "Equilateral " + polygonNames[3];			else				return polygonNames[3];		} else if (i == 4) {			if (regular)				return "Square";			else				return "Quadrilateral";		}		String s = regular ? "Regular " : "Irregular ";		if (i > 12)			return s + i + "-gon";		return s + polygonNames[i];	}	static double getCircumscribedRadius(ArchiBuilder b) {		return 100;	}	static double getInscribedRadius(ArchiBuilder b) {		return 50;	}	static AxisData getAxis(ObjectList<AxisData> l, int i) {		return l.get(i);	}	public void init() {	}}class AxisData {	OrderedTriple point1, point2;	int fold;	AxisData() {	}	AxisData(OrderedTriple p1, OrderedTriple p2, int f) {		point1 = p1;		point2 = p2;		fold = f;	}}