/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.geom;import java.util.Arrays;
import java.util.IdentityHashMap;

import com.quantimegroup.solutions.archimedean.common.SolidDefinition;
import com.quantimegroup.solutions.archimedean.utils.IntList;
import com.quantimegroup.solutions.archimedean.utils.Misc;
import com.quantimegroup.solutions.archimedean.utils.ObjectList;
import com.quantimegroup.solutions.archimedean.utils.OrderedTriple;
import com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix;
public class ArchiBuilder {	ObjectList<OrderedTriple> points;	ObjectList<OrderedTriple> vectors;	protected ObjectList<ArchiCorner> corners;	ObjectList<OrderedTriple> nonUpdatingPoints;	private ObjectList<ArchiFacet> sides;	ObjectList<ObjectList<OrderedTriple>> firstSides;	boolean ambiguous = false;	int ambiguousPoly = 0;	public static final double EDGE_LENGTH = 100;	private int type;	int[] signature;	private static double maxError = 0;	private boolean untwist = true;	private static final boolean VERBOSE = false;	private ArchiBuilder dualPartner = null;	// original	public final static double REGISTER_POINT_EPSILON = 1e-8;	private static double COMMIT_EPSILON = 1e-5;	private static double FIND_APPROX_POINT_EPSILON = 1e-2;	public int getType() {		return type;	}	protected void setType(int type) {		this.type = type;	}	protected ArchiCorner createArchiCorner() {		return new ArchiCorner();	}	protected ArchiBuilder createArchiBuilder() {		return new ArchiBuilder();	}	public ArchiBuilder looseArchiBuilder(int numEdges) throws Exception {		ArchiBuilder looseBuilder = new ArchiBuilder();		looseBuilder.setPoints(new ObjectList<OrderedTriple>(200));		looseBuilder.setSides(new ObjectList<ArchiFacet>(1));		looseBuilder.setVectors(new ObjectList<OrderedTriple>(1));		ObjectList<OrderedTriple> s = GeometryUtils.createPoly(numEdges, EDGE_LENGTH);		double r = getMaxRadius();		OrderedTriple[] p = new OrderedTriple[s.num];		for (int i = 0; i < s.num; ++i) {			p[i] = (OrderedTriple) s.get(i);			p[i].y = -Math.sqrt(r * r - p[i].x * p[i].x - p[i].z * p[i].z);		}		ArchiFacet looseSide = new ArchiFacet(p[0], p[1], p[2], s, looseBuilder);		looseSide.setPoints(looseBuilder.getPoints());		looseSide.setVectors(looseBuilder.getVectors());		looseSide.setNormal(looseBuilder.getVectors().addReturnIndex(looseSide.calcNormal()));		looseBuilder.getSides().add(looseSide);		return looseBuilder;	}	public ArchiBuilder manualArchiBuilder(int[] polyTypes, int numPolys) {		ArchiBuilder starter = createArchiBuilder();		starter.maxError = 0;		starter.type = SolidDefinition.getSolidType(polyTypes, numPolys);		starter.points = new ObjectList<OrderedTriple>(10000);		starter.corners = new ObjectList<ArchiCorner>(10000);		starter.vectors = new ObjectList<OrderedTriple>(10000);		starter.sides = new ObjectList<ArchiFacet>(10000);		try {			starter.createFirstSides(polyTypes, numPolys);			starter.getAmbiguous();			double poleTheta = ArchiCorner.computePoleTheta(starter.firstSides, starter.EDGE_LENGTH);			ArchiCorner.createFirstCorner(starter.firstSides, starter.EDGE_LENGTH, numPolys, poleTheta, starter, false);			ArchiCorner c = starter.getCorner(0);			OrderedTriple P1 = c.getHubPoint().mid(c.getSpoke(0));			OrderedTriple n = c.getHubPoint().minus(c.getSpoke(0));			OrderedTriple perp = n.arbitraryPerpendicular();			OrderedTriple P2 = P1.plus(perp);			OrderedTriple P3 = P1.plus(perp.cross(n));			OrderedTriple L1 = new OrderedTriple(0, 100, 0);			OrderedTriple L2 = OrderedTriple.origin();			OrderedTriple center = OrderedTriple.sectPlaneLine(P1, P2, P3, L1, L2);			for (int i = 0; i < starter.points.num; ++i) {				OrderedTriple p = starter.getPoint(i);				p.minusEquals(center);				if (OrderedTriple.isApprox(p.x, 0, REGISTER_POINT_EPSILON))					p.x = 0;				if (OrderedTriple.isApprox(p.y, 0, REGISTER_POINT_EPSILON))					p.y = 0;				if (OrderedTriple.isApprox(p.z, 0, REGISTER_POINT_EPSILON))					p.z = 0;			}		} catch (java.lang.Exception e) {			starter.center();			starter.type = SolidDefinition.UNDEFINED;			System.out.println(e.getMessage());		}		return starter;	}	public ArchiBuilder() {	}	public ArchiBuilder(int[] polyTypes) throws Exception {		this(polyTypes, polyTypes.length);	}	public ArchiBuilder(int[] polyTypes, int numPolys) throws Exception {		this(polyTypes, numPolys, true);	}	protected void identify() {	}	public ArchiBuilder(int[] polyTypes, int numPolys, boolean untwist) throws Exception {		this.untwist = untwist;		maxError = 0;		type = SolidDefinition.getSolidType(polyTypes, numPolys);		points = new ObjectList<OrderedTriple>(10000);		corners = new ObjectList<ArchiCorner>(10000);		vectors = new ObjectList<OrderedTriple>(10000);		sides = new ObjectList<ArchiFacet>(10000);		createFirstSides(polyTypes, numPolys);		getAmbiguous();		double poleTheta = ArchiCorner.computePoleTheta(firstSides, EDGE_LENGTH);		ArchiCorner.createFirstCorner(firstSides, EDGE_LENGTH, numPolys, poleTheta, this);		if (ambiguous && !isComplete()) {			recurse(numPolys, poleTheta);		}		identify();		center();		if (VERBOSE) {			System.out.println("corners: " + corners.num + ", points: " + points.num + ", ratio: " + ((double) corners.num) / points.num);		}		signature = getCorner(0).getSignature();		// print();	}	public Surface createSurface() {		// square();		ObjectList<OrderedTriple> points = getPoints();		Surface surface = new Surface(points);		ObjectList<ArchiFacet> sides = getSides();		for (ArchiFacet side : sides) {			int[] pointIndices = side.getVertexIndices().ints;			OrderedTriple normal = side.getNormal();			Facet facet = new Facet(surface);			facet.init(pointIndices, normal);			facet.setStateCalculator(side.getStateCalculator());			facet.setShapeCalculator(side.getShapeCalculator());			surface.addRootFacet(facet);		}		return surface;	}	public void recurse(int numSpokes, double poleTheta) throws Exception {		ArchiFacet s1 = null, s2 = null;		OrderedTriple newHub = null;		int hubIndex, s1index, s2index;		for (int c = 0; c < corners.num; ++c) {// these two loops find the first			// uncompleted corner			ArchiCorner curCorner = (ArchiCorner) corners.get(c);			for (int s = 0; s < curCorner.getSpokes().num; ++s) {				newHub = (OrderedTriple) curCorner.getSpoke(s);				hubIndex = curCorner.getSpokes().get(s);				s1 = curCorner.wrapgetSide(s);				s1index = curCorner.getSides().get(s);				s2 = curCorner.wrapgetSide(s - 1);				s2index = curCorner.getSides().wrapget(s - 1);				if (cornerIsBuilt(hubIndex, s1index, s2index) == -1) {					s = curCorner.getSpokes().num;					c = corners.num;					break;				}			}		}		ArchiCorner c = ArchiCorner.simpleCorner(newHub, s1, s2, numSpokes, poleTheta, this);// hub,		// 3		// spokes,		// pole		State state = getState();		for (int nextPosition = c.getFirstSides(s1, s2, 0, numSpokes);; nextPosition = c.getFirstSides(s1, s2, nextPosition, numSpokes)) {			try {				c.complete(numSpokes, poleTheta, 0);				if (isComplete())					break;				recurse(numSpokes, poleTheta);				if (isComplete())					break;			} catch (Exception e) {				setState(state);				c.getSpokes().num = 3;				c.getSides().num = 0;				continue;			}		}	}	public boolean isComplete() throws Exception {		if (points.num == corners.num)			return true;		if (untwist == true) {			int[] sign = getCorner(0).getSignature();			int[] bug = {					3, 4, 4, 4 };			if (Misc.arrayCompare(sign, bug) != 0)				return false;			// if( any square has only 1 triangle )			int numNeighbors = 0;			int numTriangles = 0;			for (int i = 0; i < sides.num; ++i) {				ArchiFacet si = getSide(i);				if (si.getVertexCount() != 4)					continue;				numNeighbors = 0;				numTriangles = 0;				for (int j = 0; j < sides.num; ++j) {					if (j == i)						continue;					ArchiFacet sj = getSide(j);					if (si.isAdjacent(sj)) {						++numNeighbors;						if (sj.getVertexCount() == 3)							numTriangles++;					}				}				if (numNeighbors == 4 && numTriangles == 1)					throw new Exception("3444 exception");			}		}		return false;	}	void getAmbiguous() {		ambiguous = false;		ambiguousPoly = 0;		int p1, p2, p3, curPoly;		p1 = p2 = p3 = curPoly = 0;		for (int i = 0; i < firstSides.num + 2; ++i) {			ObjectList<OrderedTriple> s = firstSides.wrapget(i);			p3 = s.num;			if (p3 == p2 && p3 == p1) {				ambiguousPoly = p3;				ambiguous = true;				break;			} else {				p1 = p2;				p2 = p3;				curPoly = p1;			}		}		if (ambiguous) {			for (int i = 0; i < firstSides.num; ++i) {				ObjectList<OrderedTriple> s = firstSides.get(i);				if (s.num != ambiguousPoly) {					return;				}			}			ambiguous = false;		}	}	void createFirstSides(int[] polyTypes, int numPolys) throws Exception {		firstSides = new ObjectList<ObjectList<OrderedTriple>>(numPolys);		for (int i = 0; i < numPolys; ++i) {			ObjectList<OrderedTriple> s = GeometryUtils.createPoly(polyTypes[i], EDGE_LENGTH);			firstSides.add(s);		}	}	int registerPointExactMatch(OrderedTriple p) {// adds point if it isn't		// already there, returns it or		// the one it found		Class pClass = p.getClass();		for (int i = 0; i < points.num; ++i) {			OrderedTriple curp = getPoint(i);			if (curp.getClass() == pClass && p.equals(curp))				return i;		}		return points.addReturnIndex(p);	}	public int registerPoint(OrderedTriple p) throws Exception {// adds point if		// it		// isn't already there,		// returns it or the one		// it found		if (p instanceof TransformablePoint) {			return points.addReturnIndex(p);		}		if (OrderedTriple.isApprox(p.x, 0, REGISTER_POINT_EPSILON))			p.x = 0;		if (OrderedTriple.isApprox(p.y, 0, REGISTER_POINT_EPSILON))			p.y = 0;		if (OrderedTriple.isApprox(p.z, 0, REGISTER_POINT_EPSILON))			p.z = 0;		Class pClass = p.getClass();		for (int i = 0; i < points.num; ++i) {			OrderedTriple curp = (OrderedTriple) points.get(i);			if (curp instanceof TransformablePoint) {				continue;			}			if (curp.getClass() == pClass) {				if (p.distanceSquared(curp) < REGISTER_POINT_EPSILON) {// if it's					// extremely					// close to a					// point					double error = p.distance(curp);					if (error > maxError)						maxError = error;					return i;				}				if (ambiguous && p.distance(curp) < EDGE_LENGTH * 0.99)// if it's too					// far					// to be the same					// but too close					// to be					// legitimate					throw new Exception("EXCEPTION: overlapping sides.");			}		}		return points.addReturnIndex(p);	}	static public int findApproxPoint(OrderedTriple p, ObjectList<OrderedTriple> l) {		for (int i = 0; i < l.num; ++i) {			OrderedTriple curp = l.get(i);			if (curp.isApprox(p, FIND_APPROX_POINT_EPSILON))				return i;		}		return -1;	}	int registerCorner(ArchiCorner c) {		return corners.addReturnIndex(c);	}	public int registerSide(ArchiFacet s) {		OrderedTriple n = s.calcNormal();		s.setNormal(vectors.addReturnIndex(n));		return sides.addReturnIndex(s);	}	int cornerIsBuilt(int p, int s1i, int s2i) {		ArchiFacet s1 = getSide(s1i);		ArchiFacet s2 = getSide(s2i);		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = (ArchiCorner) corners.get(i);			if (c.getHub() == p) {				for (int j = 0; j < c.getSides().num; ++j) {					if (c.getSide(j) == s1 && c.wrapgetSide(j + 1) == s2)						return 1;				}			}		}		return -1;	}	int sideIsBuilt(OrderedTriple p1, OrderedTriple p2, OrderedTriple p3) {		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = (ArchiFacet) sides.get(i);			int index = s.findPoint(p1);			if (index != -1 && s.wrapgetPoint(index + 1) == p2 && s.wrapgetPoint(index + 2) == p3)				return i;		}		return -1;	}	private ArchiCorner findCorner(OrderedTriple h) {		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			if (h == c.getHubPoint())				return c;		}		return null;	}	void center() {		ArchiCorner c = (ArchiCorner) corners.get(0);		OrderedTriple p1 = c.getHubPoint();		OrderedTriple p2 = p1.plus(c.getPole());		c = (ArchiCorner) corners.get(1);		OrderedTriple p3 = c.getHubPoint();		OrderedTriple p4 = p3.plus(c.getPole());		OrderedTriple center = OrderedTriple.sectLines(p1, p2, p3, p4);		for (int i = 0; i < points.num; ++i) {			OrderedTriple p = (OrderedTriple) points.get(i);			p.minusEquals(center);			if (OrderedTriple.isApprox(p.x, 0, REGISTER_POINT_EPSILON))				p.x = 0;			if (OrderedTriple.isApprox(p.y, 0, REGISTER_POINT_EPSILON))				p.y = 0;			if (OrderedTriple.isApprox(p.z, 0, REGISTER_POINT_EPSILON))				p.z = 0;		}	}	public ArchiFacet getSide(int i) {		return (ArchiFacet) sides.get(i);	}	ArchiFacet wrapgetSide(int i) {		return (ArchiFacet) sides.wrapget(i);	}	public ArchiCorner getCorner(int i) {		return (ArchiCorner) corners.get(i);	}	ArchiCorner wrapgetCorner(int i) {		return (ArchiCorner) corners.wrapget(i);	}	public OrderedTriple getPoint(int i) {		return (OrderedTriple) points.get(i);	}	OrderedTriple wrapgetPoint(int i) {		return (OrderedTriple) points.wrapget(i);	}	public void setPoints(ObjectList<OrderedTriple> points) {		this.points = points;	}	public void setSides(ObjectList<ArchiFacet> sides) {		this.sides = sides;	}	public void setVectors(ObjectList<OrderedTriple> vectors) {		this.vectors = vectors;	}	public void clearPoints() {		points.num = 0;	}	public void clearVectors() {		vectors.num = 0;	}	public void clearSides() {		sides.num = 0;	}	void print() {		System.out.println("points.num = " + (points == null ? "null" : String.valueOf(points.num)));		System.out.println("corners.num = " + (corners == null ? "null" : String.valueOf(corners.num)));		System.out.println("sides.num = " + (sides == null ? "null" : String.valueOf(sides.num)));		System.out.println("vectors.num = " + (vectors == null ? "null" : String.valueOf(vectors.num)));		System.out.println("edgeLength = " + EDGE_LENGTH);		// System.out.println( "maxEdgeLength = " + maxEdgeLength );		System.out.println();	}	double truncStage1() {		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		ArchiFacet s = c.getSide(0);		double l = EDGE_LENGTH;		double theta = ArchiCorner.polyAngle(s.getVertexCount());		double x = l / (2 * Math.sin(theta / 2) + 2);// distance along a spoke		OrderedTriple v = c.getSpoke(0).minus(c.getHubPoint()).unit().times(x);// vector		// with		// length		// x		return pole.comp(v) / radius * 100;	}	double truncStage2() {		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		OrderedTriple v = c.getSpoke(0).minus(c.getHubPoint()).dividedBy(2);		return pole.comp(v) / radius * 100;	}	double truncStage3() {		double radius = getMinRadius();		ArchiCorner corner = getCorner(0);		OrderedTriple pole = corner.getPole();		ArchiFacet s0 = corner.getSide(0);		ArchiFacet s1 = corner.getSide(1);		OrderedTriple a, b, c, d, e, f, g, x, y, z, S, T, U;		double K, A, B, C, roots[];		a = corner.getHubPoint().mid(corner.getSpoke(0));		b = corner.getHubPoint().mid(corner.getSpoke(1));		c = GeometryUtils.getCenter(s0);		d = GeometryUtils.getCenter(s1);		x = c.minus(a);		y = c.minus(b);		z = d.minus(b);		S = b.minus(a);		T = y.minus(x);		U = y.minus(z);		A = T.lengthSquared() - U.lengthSquared();		B = 2 * S.dot(T);		C = S.lengthSquared();		try {			roots = OrderedTriple.solveQuadratic(A, B, C);		} catch (Exception exc) {			return 0;		}		if (roots.length == 1)			K = roots[0];		else if (roots.length == 3)			K = roots[2];		else if (roots[0] > 0 && roots[0] < 1)			K = roots[0];		else			K = roots[1];		OrderedTriple p = a.plus(x.times(K));		OrderedTriple v = p.minus(corner.getHubPoint());		return pole.comp(v) / radius * 100;	}	double truncStage4() {		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		ArchiFacet s = c.getSide(0);		OrderedTriple center = GeometryUtils.getCenter(s);		OrderedTriple v = center.minus(c.getHubPoint());		return pole.comp(v) / radius * 100;	}	public double[] calcStellateStages() {		return new double[] {				0, 25, 50, 100 };	}	public double[] calcEdgeTruncStages() {		double ts[] = new double[5];		ts[0] = 0;		int numStages = 1;		// double radius = getPoint( 0 ).length();		ArchiCorner c = getCorner(0);		OrderedTriple truncVector;		ArchiFacet minSide = null;		int lastMinPoints = 0;		do {			minSide = null;			for (int i = 0; i < c.getSides().num; ++i) {				ArchiFacet s = c.getSide(i);				if (s.getVertexCount() > lastMinPoints && (minSide == null || s.getVertexCount() < minSide.getVertexCount())) {					minSide = s;				}			}			if (minSide == null)				break;			OrderedTriple p1 = minSide.wrapgetPoint(minSide.findIndex(c.getHub()));			OrderedTriple p2 = minSide.wrapgetPoint(minSide.findIndex(c.getHub()) + 1);			OrderedTriple mid = p1.mid(p2);			truncVector = mid.negative();			double radius = mid.length();			OrderedTriple center = GeometryUtils.getCenter(minSide);			OrderedTriple v = center.minus(mid);			ts[numStages] = truncVector.comp(v) / radius * 100;			++numStages;			lastMinPoints = minSide.getVertexCount();		} while (minSide != null);		double[] result = new double[numStages];		System.arraycopy(ts, 0, result, 0, numStages);		return result;	}	double[] calcArchiTruncStages(int[] polys, int numPolys) {		double ts[] = new double[5];		ts[0] = 0;		ts[1] = truncStage2();		int numStages = 2;		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		ArchiFacet minSide = null;		int lastMinPoints = 0;		do {			minSide = null;			for (int i = 0; i < c.getSides().num; ++i) {				ArchiFacet s = c.getSide(i);				if (s.getVertexCount() > lastMinPoints && (minSide == null || s.getVertexCount() < minSide.getVertexCount())) {					minSide = s;				}			}			if (minSide == null)				break;			OrderedTriple center = GeometryUtils.getCenter(minSide);			OrderedTriple v = center.minus(c.getHubPoint());			ts[numStages] = pole.comp(v) / radius * 100;			++numStages;			lastMinPoints = minSide.getVertexCount();		} while (minSide != null);		double[] result = new double[numStages];		System.arraycopy(ts, 0, result, 0, numStages);		return result;	}	public double[] calcCornerTruncStages() {		double[] result = null;		ArchiCorner c = getCorner(0);		int[] polys = new int[c.getSpokes().num];		for (int i = 0; i < polys.length; ++i) {			polys[i] = c.getSide(i).getVertexCount();		}		switch (SolidDefinition.getSolidType(polys)) {		case SolidDefinition.PLATONIC:			double[] temp1 = {					0, truncStage1(), truncStage2(), truncStage3(), truncStage4() };			result = temp1;			break;		case SolidDefinition.ARCHIMEDEAN:			result = calcArchiTruncStages(polys, polys.length);			break;		}		return result;	}	int countCornersWithHubAndSpoke(int hubIndex, int spokeIndex, IntList sideIndices) {		int count = 0;		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			if (c.getHub() == hubIndex) {				if (c.getSpokes().find(spokeIndex) >= 0 && c.getSides().intersect(sideIndices).size() == 2) {					count++;				}			}		}		return count;	}	int findCornerByHubAndSpokeAndSides(int hubIndex, int spokeIndex, IntList sideIndices) {		int count = countCornersWithHubAndSpoke(hubIndex, spokeIndex, sideIndices);		if (count > 1) {			System.out.println(count);		}		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			if (c.getHub() == hubIndex) {				if (c.getSpokes().find(spokeIndex) >= 0 && c.getSides().intersect(sideIndices).size() == 2) {					return i;				}			}		}		return -1;	}	private void setCornerTruncCalculators(ArchiFacet truncSide, final int polyType, final IntList sortedPolyTypes, boolean platonic,			boolean corner, final double[] truncPercents) {		int rank = sortedPolyTypes.find(polyType);		if (platonic) {			if (corner) {				truncSide.setStateCalculator(FacetStateCalculator.greaterThan(0, new FacetState(true, false), new FacetState(false, false)));				truncSide.setShapeCalculator(new FacetShapeCalculator() {					public FacetShape calcShape(double truncPercent) {						if (truncPercent <= truncPercents[2]) {							return new FacetShape(signature.length, true);						} else if (truncPercent < truncPercents[3]) {							return new FacetShape(signature.length * 2, false);						} else if (truncPercent == truncPercents[3]) {							return new FacetShape(signature.length * 2, true);						} else if (truncPercent < truncPercents[4]) {							return new FacetShape(signature.length * 2, false);						} else if (truncPercent == truncPercents[4]) {							return new FacetShape(signature.length, true);						}						return null;					}				});			} else {				truncSide.setStateCalculator(FacetStateCalculator.lessThan(truncPercents[rank + 4], new FacetState(true, true), new FacetState(						false, true)));				truncSide.setShapeCalculator(new FacetShapeCalculator() {					public FacetShape calcShape(double truncPercent) {						if (truncPercent <= truncPercents[0]) {							return new FacetShape(polyType, true);						} else if (truncPercent < truncPercents[1]) {							return new FacetShape(polyType * 2, false);						} else if (truncPercent == truncPercents[1]) {							return new FacetShape(polyType * 2, true);						} else if (truncPercent < truncPercents[2]) {							return new FacetShape(polyType * 2, false);						} else {							return new FacetShape(polyType, true);						}					}				});			}		} else {			if (corner) {				truncSide.setStateCalculator(FacetStateCalculator.greaterThan(0, new FacetState(true, false), new FacetState(false, false)));				truncSide.setShapeCalculator(new FacetShapeCalculator() {					public FacetShape calcShape(double truncPercent) {						if (truncPercent <= truncPercents[1]) {							return new FacetShape(signature.length, false);						} else if (truncPercent < truncPercents[2]) {							return new FacetShape(signature.length * 2, false);						} else if (truncPercent < truncPercents[3]) {							int numVertices = signature.length * 2 - Misc.countOccurences(signature, sortedPolyTypes.get(0));							return new FacetShape(numVertices, false);						} else if (truncPercent == truncPercents[3] && truncPercents.length == 4) {							int numVertices = signature.length * 2 - Misc.countOccurences(signature, sortedPolyTypes.get(0))									- Misc.countOccurences(signature, sortedPolyTypes.get(1));							return new FacetShape(numVertices, false);						} else if (truncPercent < truncPercents[4]) {							int numVertices = signature.length * 2 - Misc.countOccurences(signature, sortedPolyTypes.get(1))									- Misc.countOccurences(signature, sortedPolyTypes.get(0));							return new FacetShape(numVertices, false);						} else if (truncPercent == truncPercents[4] && truncPercents.length == 5) {							int numVertices = signature.length * 2 - Misc.countOccurences(signature, sortedPolyTypes.get(0))									- Misc.countOccurences(signature, sortedPolyTypes.get(1)) - Misc.countOccurences(signature, sortedPolyTypes.get(2));							return new FacetShape(numVertices, false);						}						return null;					}				});			} else {				truncSide.setStateCalculator(FacetStateCalculator.lessThan(truncPercents[rank + 2], new FacetState(true, true), new FacetState(						false, true)));				truncSide.setShapeCalculator(FacetShapeCalculator.between(truncPercents[0], truncPercents[1], new FacetShape(polyType * 2, false),						new FacetShape(polyType, true)));			}		}	}	private void setEdgeTruncCalculators(ArchiFacet truncSide, final int polyType, final IntList sortedPolyTypes, boolean edge,			final int vertexCount1, final int vertexCount2, final double[] truncPercents) {		int rank = sortedPolyTypes.find(polyType);		if (edge) {			truncSide.setStateCalculator(new FacetStateCalculator() {				FacetState real = new FacetState(true, false);				FacetState notReal = new FacetState(false, false);				public FacetState calcState(double truncPercent) {					return truncPercent <= 0 ? notReal : real;				}			});			truncSide.setShapeCalculator(new FacetShapeCalculator() {				public FacetShape calcShape(double truncPercent) {					if (truncPercent < truncPercents[1]) {						return new FacetShape(6, false);					} else if (truncPercent >= truncPercents[truncPercents.length - 1]) {						return new FacetShape(4, false);					} else if (truncPercent < truncPercents[2]) {						int vertexCount = 6;						if (sortedPolyTypes.get(0) == vertexCount1) {							vertexCount--;						}						if (sortedPolyTypes.get(0) == vertexCount2) {							vertexCount--;						}						return new FacetShape(vertexCount, false);					} else if (truncPercent < truncPercents[3]) {						int vertexCount = 6;						if (sortedPolyTypes.get(0) == vertexCount1) {							vertexCount--;						}						if (sortedPolyTypes.get(0) == vertexCount2) {							vertexCount--;						}						if (sortedPolyTypes.get(1) == vertexCount1) {							vertexCount--;						}						if (sortedPolyTypes.get(1) == vertexCount2) {							vertexCount--;						}						return new FacetShape(vertexCount, false);					} else {						return new FacetShape(4, false);					}				}			});		} else {			truncSide.setStateCalculator(new FacetStateCalculator() {				FacetState real = new FacetState(true, true);				FacetState notReal = new FacetState(false, true);				public FacetState calcState(double truncPercent) {					int triggerTrunc = sortedPolyTypes.find(polyType) + 1;					return truncPercent < truncPercents[triggerTrunc] ? real : notReal;				}			});		}	}	public ArchiBuilder prepareCornerTrunc() {		IdentityHashMap<ArchiFacet, Object> handledSides = new IdentityHashMap<ArchiFacet, Object>();		ArchiBuilder trunc = createArchiBuilder();		trunc.setSides(new ObjectList<ArchiFacet>(getSideCount() + corners.size()));		trunc.setVectors(new ObjectList<OrderedTriple>(getSideCount() + corners.size()));		trunc.points = new ObjectList<OrderedTriple>(100, 100);		trunc.nonUpdatingPoints = new ObjectList<OrderedTriple>(100, 100);		trunc.signature = signature;		trunc.type = type;		int[] sortedSignature = signature.clone();		Arrays.sort(sortedSignature);		IntList temp = new IntList(sortedSignature);		temp.orderedRemoveDuplicates();		final IntList sortedPolyTypes = temp;		double[] truncPercents = calcCornerTruncStages();		int originIndex = trunc.nonUpdatingPoints.addReturnIndex(OrderedTriple.origin());		for (ArchiCorner corner : corners) {			ArchiFacet cornerSide = new ArchiFacet();			int cornerPolyType = corner.getSpokes().size();			setCornerTruncCalculators(cornerSide, cornerPolyType, sortedPolyTypes, type == SolidDefinition.PLATONIC, true, truncPercents);			trunc.sides.add(cornerSide);			cornerSide.setPoints(trunc.points);			IntList cornerSideIndices = new IntList(corner.getSpokes().size() * 2);			cornerSide.setVertexIndices(cornerSideIndices);			cornerSide.setVectors(trunc.vectors);			int cornerNormalIndex = trunc.vectors.addReturnIndex(new OrderedTriple(corner.getHubPoint()));			cornerSide.setNormal(cornerNormalIndex);			OrderedTriple hub = corner.getHubPoint();			for (int i = 0; i < corner.getSides().size(); ++i) {				int sideIndex = corner.getSides().get(i);				OrderedTriple mid = corner.getSpoke(i).mid(hub);				int midIndex = trunc.nonUpdatingPoints.addReturnIndex(mid);				ArchiFacet af = corner.getSide(i);				int flankPolyType = af.getVertexCount();				OrderedTriple curCenter = GeometryUtils.getCenter(af);				int curCenterIndex = trunc.nonUpdatingPoints.addReturnIndex(curCenter);				int curPolyType = af.getVertexCount();				int curRank = sortedPolyTypes.find(curPolyType);				ArchiFacet prevSide = corner.wrapgetSide(i - 1);				OrderedTriple prevCenter = GeometryUtils.getCenter(prevSide);				int nextCenterIndex = trunc.nonUpdatingPoints.addReturnIndex(prevCenter);				int prevPolyType = prevSide.getVertexCount();				int prevRank = sortedPolyTypes.find(prevPolyType);				double midTruncPercent = 0;				double centerTruncPercent = 0;				double prevCenterTruncPercent = 0;				if (canCornerTrunc(type)) {					if (type == SolidDefinition.PLATONIC) {						midTruncPercent = truncPercents[2];						centerTruncPercent = truncPercents[4];						prevCenterTruncPercent = truncPercents[4];					}else{						midTruncPercent = truncPercents[1];						centerTruncPercent = truncPercents[curRank + 2];						prevCenterTruncPercent = truncPercents[prevRank + 2];					}				} else {					System.out.println("Unhandled type");				}//				if (type == SolidDefinition.ARCHIMEDEAN || type == ExtendedSolidDefinition.RATIONAL) {//					midTruncPercent = truncPercents[1];//					centerTruncPercent = truncPercents[curRank + 2];//					prevCenterTruncPercent = truncPercents[prevRank + 2];//				} else if (type == SolidDefinition.PLATONIC) {//					midTruncPercent = truncPercents[2];//					centerTruncPercent = truncPercents[4];//					prevCenterTruncPercent = truncPercents[4];//				} else {//					System.out.println("Unhandled type");//				}				int cornerStartIndex = trunc.nonUpdatingPoints.addReturnIndex(new OrderedTriple(hub));				TransformablePoint cornerct2 = new TransformablePoint(trunc.nonUpdatingPoints, cornerStartIndex);				int cornerct2Index = trunc.points.addReturnIndex(cornerct2);				cornerSideIndices.add(cornerct2Index);				cornerct2.addStage(cornerStartIndex, truncPercents[0]);				cornerct2.addStage(midIndex, midTruncPercent);				cornerct2.addStage(nextCenterIndex, prevCenterTruncPercent);				cornerct2.addStage(originIndex, 100);				TransformablePoint cornerct1 = new TransformablePoint(trunc.nonUpdatingPoints, cornerStartIndex);				int cornerct1Index = trunc.points.addReturnIndex(cornerct1);				cornerSideIndices.add(cornerct1Index);				cornerct1.addStage(cornerStartIndex, truncPercents[0]);				cornerct1.addStage(midIndex, midTruncPercent);				cornerct1.addStage(curCenterIndex, centerTruncPercent);				cornerct1.addStage(originIndex, 100);				if (handledSides.containsKey(af)) {					continue;				}				handledSides.put(af, null);				OrderedTriple afCenter = GeometryUtils.getCenter(af);				int centerIndex = trunc.nonUpdatingPoints.addReturnIndex(new OrderedTriple(afCenter));				ArchiFacet flank = new ArchiFacet();				setCornerTruncCalculators(flank, flankPolyType, sortedPolyTypes, type == SolidDefinition.PLATONIC, false, truncPercents);				trunc.sides.add(flank);				flank.setPoints(trunc.points);				IntList flankIndices = new IntList(af.getVertexCount() * 2);				flank.setVertexIndices(flankIndices);				flank.setVectors(trunc.vectors);				int flankNormalIndex = trunc.vectors.addReturnIndex(af.getNormal());				flank.setNormal(flankNormalIndex);				for (int vertexIndex = 0; vertexIndex < af.getVertexCount(); ++vertexIndex) {					OrderedTriple curp = af.getPoint(vertexIndex);					int flankStartIndex = trunc.nonUpdatingPoints.addReturnIndex(new OrderedTriple(curp));					OrderedTriple prevp = af.wrapgetPoint(vertexIndex - 1);					OrderedTriple nextp = af.wrapgetPoint(vertexIndex + 1);					TransformablePoint ct1 = new TransformablePoint(trunc.nonUpdatingPoints, flankStartIndex);					int ct1Index = trunc.points.addReturnIndex(ct1);					flankIndices.add(ct1Index);					OrderedTriple mid1 = curp.mid(prevp);					int mid1Index = trunc.nonUpdatingPoints.addReturnIndex(mid1);					ct1.addStage(flankStartIndex, truncPercents[0]);					ct1.addStage(mid1Index, midTruncPercent);					ct1.addStage(centerIndex, centerTruncPercent);					ct1.addStage(originIndex, 100);					TransformablePoint ct2 = new TransformablePoint(trunc.nonUpdatingPoints, flankStartIndex);					int ct2Index = trunc.points.addReturnIndex(ct2);					flankIndices.add(ct2Index);					OrderedTriple mid2 = curp.mid(nextp);					int mid2Index = trunc.nonUpdatingPoints.addReturnIndex(mid2);					ct2.addStage(flankStartIndex, truncPercents[0]);					ct2.addStage(mid2Index, midTruncPercent);					ct2.addStage(centerIndex, centerTruncPercent);					ct2.addStage(originIndex, 100);				}			}		}		return trunc;	}	protected boolean canCornerTrunc(int type) {		return type == SolidDefinition.PLATONIC || type == SolidDefinition.ARCHIMEDEAN;	}	public ArchiBuilder dual() {		if (dualPartner != null) {			return dualPartner;		}		ArchiBuilder dual = createArchiBuilder();		dual.sides = new ObjectList<ArchiFacet>(corners.num);		dual.points = new ObjectList<OrderedTriple>(sides.num);		dual.points.num = sides.num;		dual.vectors = new ObjectList<OrderedTriple>(corners.num);		for (ArchiCorner c : corners) {			OrderedTriple pole = c.getPole();			OrderedTriple h = c.getHubPoint();			for (int j = 0; j < c.getSides().num; ++j) {				int s = c.getSides().get(j);				if (dual.getPoint(s) != null)					continue;				OrderedTriple spoke1 = c.getSpoke(j);				OrderedTriple spoke2 = c.wrapgetSpoke(j + 1);				OrderedTriple spokev1 = spoke1.minus(h);				OrderedTriple spokev2 = spoke2.minus(h);				OrderedTriple v1 = spokev1.cross(pole);				OrderedTriple v2 = spokev2.cross(pole);				OrderedTriple m1 = h.mid(spoke1);				OrderedTriple m2 = h.mid(spoke2);				dual.points.set(s, OrderedTriple.sectLines(m1, m1.plus(v1), m2, m2.plus(v2)));			}			ArchiFacet s = new ArchiFacet(c.getSpokes().num);			s.setStateCalculator(new FacetStateCalculator() {				FacetState state = new FacetState(true, false);				public FacetState calcState(double truncPercent) {					return state;				}			});			s.setVertexIndices(c.getSides().copy());			s.setPoints(dual.points);			s.setVectors(dual.vectors);			s.setNormal(dual.vectors.addReturnIndex(s.calcNormal()));			dual.sides.add(s);		}		if (type == SolidDefinition.PLATONIC)			dual.type = SolidDefinition.PLATONIC;		else			dual.type = SolidDefinition.DUAL;		dual.signature = signature;		dualPartner = dual;		dual.dualPartner = this;		return dual;	}	public ArchiBuilder antiDual() {		if (dualPartner != null) {			return dualPartner;		}		ArchiBuilder antiDual = new ArchiBuilder();		antiDual.sides = new ObjectList<ArchiFacet>(corners.num);		antiDual.points = new ObjectList<OrderedTriple>(sides.num);		antiDual.vectors = new ObjectList<OrderedTriple>(corners.num);		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = getSide(i);			antiDual.points.add(GeometryUtils.getIncenter(s.getPoint(0), s.getPoint(1), s.getPoint(2), s.wrapgetPoint(3)));		}		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			ArchiFacet s = new ArchiFacet(c.getSpokes().num);			s.setVertexIndices(c.getSides().copy());			s.setPoints(antiDual.points);			s.setVectors(antiDual.vectors);			s.setNormal(antiDual.vectors.addReturnIndex(s.calcNormal()));			antiDual.sides.add(s);		}		ArchiCorner c = getCorner(0);		IntList spokes = c.getSpokes();		OrderedTriple p1 = c.getHubPoint();		OrderedTriple p2 = c.getSpoke(1);		int s1 = c.getSides().get(0);		OrderedTriple p3 = antiDual.getPoint(s1);		int s2 = c.getSides().get(1);		OrderedTriple p4 = antiDual.getPoint(s2);		OrderedTriple origin = new OrderedTriple(0, 0, 0);		double dist = OrderedTriple.sectPlaneLine(p3, p4, origin, p1, p2).length();		double dualDist = OrderedTriple.sectPlaneLine(p1, p2, origin, p3, p4).length();		double ratio = dist / dualDist;		for (int i = 0; i < antiDual.points.num; ++i) {			antiDual.getPoint(i).timesEquals(ratio);		}		antiDual.signature = signature;		antiDual.type = SolidDefinition.ARCHIMEDEAN;// sometimes it will be		// GUI.PLATONIC		return antiDual;	}	public ArchiBuilder prepareEdgeTrunc() {		int numSpokes = getCorner(0).getSpokes().num;		// set up trunc		ArchiBuilder trunc = createArchiBuilder();		trunc.type = type;		int numPoints = points.num;		int numSides = 0;		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = getSide(i);			numPoints += s.getVertexCount();			numSides += s.getVertexCount();		}		numSides = numSides / 2 + sides.num;		trunc.points = new ObjectList<OrderedTriple>(numPoints);		trunc.sides = new ObjectList<ArchiFacet>(numSides, 10);		trunc.vectors = new ObjectList<OrderedTriple>(numSides, 10);		trunc.nonUpdatingPoints = new ObjectList<OrderedTriple>(1 + sides.num + points.num);		// fill in the non-updating points		for (int i = 0; i < points.num; ++i) {			trunc.nonUpdatingPoints.add(new OrderedTriple(getPoint(i)));		}		int origin = trunc.nonUpdatingPoints.addReturnIndex(new OrderedTriple(0, 0, 0));		IntList centers = new IntList(sides.num);		for (int i = 0; i < sides.num; ++i) {			centers.add(trunc.nonUpdatingPoints.addReturnIndex(GeometryUtils.getCenter(getSide(i))));		}		// calculate cornerSpeed and create the edge truncing points		ArchiCorner corner = getCorner(0);		OrderedTriple edgev = corner.getHubPoint().mid(corner.getSpoke(0)).negative();		double totalDist = edgev.length();		for (int i = 0; i < points.num; ++i) {			TransformablePoint tp = new TransformablePoint(trunc.nonUpdatingPoints, i);			tp.addStage(origin, 100);			trunc.points.add(tp);			// trunc.points.add(new EdgeTruncablePoint(trunc.nonUpdatingPoints, i,			// origin));		}		int[] sortedSignature = signature.clone();		Arrays.sort(sortedSignature);		IntList temp = new IntList(sortedSignature);		temp.orderedRemoveDuplicates();		final IntList sortedPolyTypes = temp;		final double[] truncPercents = calcEdgeTruncStages();		// create the side-sides		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = getSide(i);			final int vertexCount = s.getVertexCount();			ArchiFacet truncSide = new ArchiFacet(s.getVertexCount());			setEdgeTruncCalculators(truncSide, vertexCount, sortedPolyTypes, false, -1, -1, truncPercents);			truncSide.setVectors(trunc.vectors);			OrderedTriple center = GeometryUtils.getCenter(s);			OrderedTriple sidev1 = center.minus(s.getPoint(0));			edgev = s.getPoint(0).mid(s.getPoint(1)).negative();			double speed = 1 / edgev.cos(sidev1);			for (int j = 0; j < s.getVertexCount(); ++j) {				TransformablePoint p = new TransformablePoint(trunc.nonUpdatingPoints, s.getIndex(j));				OrderedTriple goalPoint0 = s.getPoint(j);				int sideCenter = centers.get(i);				double poleDistance = goalPoint0.distance(trunc.nonUpdatingPoints.get(sideCenter)) / speed;				double truncPercent = poleDistance / totalDist * 100;				p.addStage(sideCenter, truncPercent);				poleDistance = goalPoint0.distance(trunc.nonUpdatingPoints.get(origin));				p.addStage(origin, 100);				// EdgeTruncablePoint p = new				// EdgeTruncablePoint(trunc.nonUpdatingPoints, s.getIndex(j),				// centers.get(i), origin, speed, totalDist);				truncSide.getVertexIndices().add(trunc.points.addReturnIndex(p));			}			truncSide.setNormal(trunc.vectors.addReturnIndex(s.getNormal()));			trunc.sides.add(truncSide);		}		// create the edge-sides		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			for (int j = 0; j < numSpokes; ++j) {				OrderedTriple spoke = c.getSpoke(j);				if (c.getHubPoint().sortOrder(spoke) == 1) {					ArchiFacet truncSide = new ArchiFacet(6);					truncSide.setPoints(trunc.points);					truncSide.setVectors(trunc.vectors);					int hub = c.getHub();					truncSide.getVertexIndices().add(hub);					final ArchiFacet s1 = c.wrapgetSide(j - 1);					int sindex = sides.find(s1);					int pindex = s1.getVertexIndices().find(hub);					truncSide.getVertexIndices().add(trunc.getSide(sindex).getIndex(pindex));					truncSide.getVertexIndices().add(trunc.getSide(sindex).wrapgetIndex(pindex - 1));					pindex = points.find(spoke);					truncSide.getVertexIndices().add(pindex);					final ArchiFacet s2 = c.wrapgetSide(j);					sindex = sides.find(s2);					pindex = s2.findPoint(spoke);					truncSide.getVertexIndices().add(trunc.getSide(sindex).getIndex(pindex));					truncSide.getVertexIndices().add(trunc.getSide(sindex).wrapgetIndex(pindex - 1));					OrderedTriple normal = truncSide.getPoint(0).mid(truncSide.getPoint(3));					truncSide.setNormal(trunc.vectors.addReturnIndex(normal));					trunc.sides.add(truncSide);					setEdgeTruncCalculators(truncSide, -1, sortedPolyTypes, true, s1.getVertexCount(), s2.getVertexCount(), truncPercents);				}			}		}		trunc.signature = signature;		return trunc;	}	/**	 * Only for 555 first stellation right now.	 * 	 * @return	 * @throws Exception	 */	public ArchiBuilder prepareStellate() {		// for each side		// for each edge		// create a new side using the two endpoints of the edge and the midpoint.		// the midpoint will move out to become the point of the star		ArchiBuilder trunc = createArchiBuilder();		// StellatablePoint.init(trunc);		trunc.points = new ObjectList<OrderedTriple>(100, 100);		trunc.vectors = new ObjectList<OrderedTriple>(100, 100);		trunc.nonUpdatingPoints = new ObjectList<OrderedTriple>(100, 100);		trunc.sides = new ObjectList<ArchiFacet>(12 * 6, 12);		for (OrderedTriple p : points) {			trunc.points.add(new OrderedTriple(p));		}		for (OrderedTriple v : vectors) {			trunc.vectors.add(new OrderedTriple(v));		}		final double[] truncPercents = calcStellateStages();		for (ArchiFacet ss : sides) {			ObjectList<OrderedTriple> goalsA = new ObjectList<OrderedTriple>(5);			IntList goalIndicesA = new IntList(5);			ObjectList<ArchiFacet> stellSidesB = new ObjectList<ArchiFacet>(5);			trunc.sides.add(ss);			for (int i = 0; i < ss.getVertexIndices().size(); ++i) {				// find or calc points and point indices				int i0 = ss.wrapgetIndex(i - 1);				int i1 = ss.wrapgetIndex(i);				int i2 = ss.wrapgetIndex(i + 1);				int i3 = ss.wrapgetIndex(i + 2);				OrderedTriple p0 = trunc.getPoint(i0);				OrderedTriple p1 = trunc.getPoint(i1);				OrderedTriple p2 = trunc.getPoint(i2);				OrderedTriple p3 = trunc.getPoint(i3);				OrderedTriple start = p1.mid(p2);				OrderedTriple goal = OrderedTriple.sectLines(p0, p1, p2, p3);				goalsA.add(goal);				// add start and goal to nonUpdatingPoints and get their assigned index				int startIndex = trunc.nonUpdatingPoints.addReturnIndex(start);				int goalIndex = trunc.nonUpdatingPoints.addReturnIndex(goal);				goalIndicesA.add(goalIndex);				// create the StellatablePoint and addStages using indices from				// nonUpdatingPoints				TransformablePoint sp = new TransformablePoint(trunc.nonUpdatingPoints, startIndex);				sp.addStage(goalIndex, 25);				sp.addStage(goalIndex, 50);				sp.addStage(goalIndex, 100);				// add StellatablePoint to points				int spIndex = trunc.points.addReturnIndex(sp);				ArchiFacet stellSideA = new ArchiFacet();				stellSideA.setStateCalculator(new FacetStateCalculator() {					public FacetState calcState(double truncPercent) {						return truncPercent <= truncPercents[0] ? FacetState.NOT_REAL : FacetState.REAL;					}				});				stellSideA.setShapeCalculator(new FacetShapeCalculator() {					public FacetShape calcShape(double truncPercent) {						return new FacetShape(5, true);					}				});				// setVertexIndices using indices assigned by points				stellSideA.setVertexIndices(new IntList(new int[] {						i1, spIndex, i2 }));				stellSideA.setNormal(ss.getNormalIndex());				stellSideA.setPoints(trunc.points);				stellSideA.setVectors(trunc.vectors);				trunc.sides.add(stellSideA);				ArchiFacet stellSideB = new ArchiFacet();				stellSideB.setStateCalculator(new FacetStateCalculator() {					public FacetState calcState(double truncPercent) {						return truncPercent <= truncPercents[1] ? FacetState.NOT_REAL : FacetState.REAL;					}				});				stellSideB.setShapeCalculator(new FacetShapeCalculator() {					public FacetShape calcShape(double truncPercent) {						return new FacetShape(5, true);					}				});				int startIndexB = trunc.nonUpdatingPoints.addReturnIndex(p1);				TransformablePoint spb1 = new TransformablePoint(trunc.nonUpdatingPoints, startIndexB);				int spbIndex1 = trunc.points.addReturnIndex(spb1);				TransformablePoint spb2 = new TransformablePoint(trunc.nonUpdatingPoints, startIndexB);				int spbIndex2 = trunc.points.addReturnIndex(spb2);				stellSideB.setVertexIndices(new IntList(new int[] {						i1, spbIndex1, spbIndex2 }));				stellSideB.setNormal(ss.getNormalIndex());				stellSideB.setPoints(trunc.points);				stellSideB.setVectors(trunc.vectors);				stellSidesB.add(stellSideB);				trunc.sides.add(stellSideB);				spb1.addStage(startIndexB, 25);				spb2.addStage(startIndexB, 25);			}			for (int i = 0; i < stellSidesB.size(); ++i) {				ArchiFacet stellSideB = stellSidesB.get(i);				int goalIndex0 = goalIndicesA.wrapget(i - 2);				int goalIndex1 = goalIndicesA.wrapget(i - 1);				int goalIndex2 = goalIndicesA.wrapget(i);				int goalIndex3 = goalIndicesA.wrapget(i + 1);				OrderedTriple goal0 = trunc.nonUpdatingPoints.get(goalIndex0);				OrderedTriple goal1 = trunc.nonUpdatingPoints.get(goalIndex1);				OrderedTriple goal2 = trunc.nonUpdatingPoints.get(goalIndex2);				OrderedTriple goal3 = trunc.nonUpdatingPoints.get(goalIndex3);				TransformablePoint spb1 = (TransformablePoint) stellSideB.getPoint(1);				spb1.addStage(goalIndex2, 50);				spb1.addStage(goalIndex2, 100);				TransformablePoint spb2 = (TransformablePoint) stellSideB.getPoint(2);				spb2.addStage(goalIndex1, 50);				spb2.addStage(goalIndex1, 100);				ArchiFacet stellSideC = new ArchiFacet();				stellSideC.setStateCalculator(new FacetStateCalculator() {					public FacetState calcState(double truncPercent) {						return truncPercent <= truncPercents[2] ? FacetState.NOT_REAL : FacetState.REAL;					}				});				stellSideC.setShapeCalculator(new FacetShapeCalculator() {					public FacetShape calcShape(double truncPercent) {						return new FacetShape(5, true);					}				});				int i0 = trunc.points.addReturnIndex(goal1);				int i1 = trunc.points.addReturnIndex(goal2);				OrderedTriple mid = goal1.mid(goal2);				int startIndex = trunc.nonUpdatingPoints.addReturnIndex(mid);				TransformablePoint sp = new TransformablePoint(trunc.nonUpdatingPoints, startIndex);				OrderedTriple finalGoal = OrderedTriple.sectLines(goal0, goal1, goal2, goal3);				int finalGoalIndex = trunc.nonUpdatingPoints.addReturnIndex(finalGoal);				sp.addStage(startIndex, 25);				sp.addStage(startIndex, 50);				sp.addStage(finalGoalIndex, 100);				int i2 = trunc.points.addReturnIndex(sp);				stellSideC.setVertexIndices(new IntList(new int[] {						i0, i1, i2 }));				stellSideC.setNormal(ss.getNormalIndex());				stellSideC.setPoints(trunc.points);				stellSideC.setVectors(trunc.vectors);				trunc.sides.add(stellSideC);			}		}		trunc.signature = signature;		return trunc;	}	double getMinRadius() {		double cur, min = Double.POSITIVE_INFINITY;		for (int i = 0; i < points.num; ++i) {			cur = getPoint(i).length();			if (cur < min)				min = cur;		}		return min;	}	public double getMaxRadius() {		double cur, max = Double.NEGATIVE_INFINITY;		for (int i = 0; i < points.num; ++i) {			cur = getPoint(i).length();			if (cur > max)				max = cur;		}		return max;	}	int[] getPointUsage() {		int[] table = new int[points.num];		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = getSide(i);			for (int j = 0; j < s.getVertexCount(); ++j) {				table[s.getIndex(j)]++;			}		}		return table;	}	public void completeCorners() {		corners = new ObjectList<ArchiCorner>(points.num);		IntList[] table = new IntList[points.num];		for (int i = 0; i < points.num; ++i) {			table[i] = new IntList(10, 5);		}		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = getSide(i);			for (int j = 0; j < s.getVertexCount(); ++j) {				table[s.getIndex(j)].add(i);			}		}		for (int i = 0; i < points.num; ++i) {			ArchiCorner c = new ArchiCorner();			c.setBoss(this);			c.setHub(i);			if (table[i].num == 0) {				Exception e = new Exception();				e.printStackTrace();			}			c.setSpokes(new IntList(table[i].num));			c.setSides(new IntList(table[i].num));			int sideIndex = table[i].get(0);			c.getSides().add(sideIndex);			ArchiFacet s = getSide(sideIndex);			int find = s.findIndex(i);			int spoke = s.wrapgetIndex(find + 1);			c.getSpokes().add(spoke);			spoke = s.wrapgetIndex(find - 1);			table[i].removeIndex(0);			while (table[i].num > 0) {				for (int j = 0; j < table[i].num; ++j) {					sideIndex = table[i].get(j);					s = getSide(sideIndex);					find = s.findIndex(spoke);					if (find != -1) {						c.getSides().add(sideIndex);						c.getSpokes().add(spoke);						spoke = s.wrapgetIndex(find - 2);						table[i].removeIndex(j);						--j;						break;					}				}			}			corners.add(c);		}		return;	}	public void reclaim() {		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = getSide(i);			s.setPoints(points);			s.setVectors(vectors);		}	}	void printType() {		System.out.println(SolidDefinition.typeToString(type));	}	public int numEdges() {		int numEdges = 0;		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = getSide(i);			numEdges += s.getVertexCount();		}		return numEdges / 2;	}	public void reflect() {		for (int i = 0; i < points.num; ++i) {			getPoint(i).timesEquals(-1);		}		for (int i = 0; i < vectors.num; ++i) {			((OrderedTriple) vectors.get(i)).timesEquals(-1);		}		if (nonUpdatingPoints != null) {			for (int i = 0; i < nonUpdatingPoints.num; ++i) {				((OrderedTriple) nonUpdatingPoints.get(i)).timesEquals(-1);			}		}		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = getSide(i);			s.getVertexIndices().reverse();		}		if (corners != null) {			for (int i = 0; i < corners.num; ++i) {				ArchiCorner c = getCorner(i);				c.getSpokes().reverse();				c.setSides(c.getSides().wrapCopy(-2, -1));				c.setPole(null);			}		}	}	public int getCornerCount() {		return corners.num;	}	public int getPointCount() {		return points.num;	}	public int getSideCount() {		return sides.num;	}	void sectLine(OrderedTriple L1, OrderedTriple L2, ArchiFacet[] sideArray, OrderedTriple[] sects) {		int n = 0;		for (int i = 0; i < sides.num; ++i) {			ArchiFacet s = getSide(i);			OrderedTriple[] p = GeometryUtils.threeDistinctPoints(s);			OrderedTriple sect = OrderedTriple.sectPlaneLine(p[0], p[1], p[2], L1, L2);			if (sect == null)				continue;			if (n > 0 && sect.isApprox(sects[0], COMMIT_EPSILON))				continue;			if (s.inside(sect)) {				sects[n] = sect;				sideArray[n] = s;				n++;				if (n == 2)					break;			}		}	}	public State getState() {		State s = new State();		s.numCorners = corners.num;		s.numVectors = vectors.num;		s.numPoints = points.num;		s.numSides = sides.num;		return s;	}	public void setState(State s) {		corners.num = s.numCorners;		vectors.num = s.numVectors;		points.num = s.numPoints;		sides.num = s.numSides;	}	public ObjectList<ArchiCorner> getCorners() {		return corners;	}	public ObjectList<OrderedTriple> getPoints() {		return points;	}	public ObjectList<OrderedTriple> getVectors() {		return vectors;	}	public ObjectList<ArchiFacet> getSides() {		return sides;	}	public int[] getSignature() {		return signature;	}	void square() {		ObjectList<OrderedTriple> ots = getPoints();		ArchiFacet firstSide = getSide(0);		OrderedTriple firstSideNormal = firstSide.calcNormal().unit();		OrderedTriple desiredFirstSideNormal = new OrderedTriple(0, 0, -1);		OrderedTriple firstEdgeVector = ots.get(1).minus(ots.get(0)).unit();		OrderedTriple desiredFirstEdgeVector = new OrderedTriple(1, 0, 0);		Quick3X3Matrix m = Quick3X3Matrix.findRotationMatrix(firstSideNormal, desiredFirstSideNormal, firstEdgeVector, desiredFirstEdgeVector);		for (OrderedTriple ot : ots) {			ot.become(OrderedTriple.round(m.times(ot), 12));		}		for (OrderedTriple v : getVectors()) {			v.become(OrderedTriple.round(m.times(v), 12));		}	}}class State {	int numCorners, numPoints, numSides, numVectors;	void print() {		System.out.println("numCorners = " + numCorners);		System.out.println("numPoints = " + numPoints);		System.out.println("numSides = " + numSides);		System.out.println("numVectors = " + numSides);		System.out.println();	}}